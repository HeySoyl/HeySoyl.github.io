{"pages":[{"title":"404","text":"404 L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"jsonPath\":\"/live2dw/assets/koharu.model.json\"},\"display\":{\"superSample\":2,\"width\":210,\"height\":420,\"position\":\"left\",\"hOffset\":0,\"vOffset\":-20},\"log\":false,\"tagMode\":false});","link":"/404.html"},{"title":"简历","text":"如果没有百分百的精力和热情，那便停下来去休息！ 关于我热爱开源项目、热爱新技术、热爱新事物、爱策略、卡牌、养成类游戏。 关于学习正在往终身学习者前进… 近期学习方向：Swift（Vapor\\iOS） 关于爱好 测试开发领域 Swift程序设计 热爱阅读，尤其喜爱科幻电影、摄影。 职业经历 2018年6月～至今 儿子、丈夫、父亲、Swift学习者准备迎接宝宝的降生，陪伴家人，并重新思考人生规划，朝向Swift开发方向学习 2016年11月～2018年6月 DIDI 测试工程师（中国 北京） 接口功能和性能测试 H5 功能测试 2015年2月～2016年9月 可为时代 测试工程师（中国 北京） 测试组长 Web功能和性能测试 联系我 Email: soyl@live.cn Phone: 18553714413","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"轻启药箱","text":"智能药箱APP当前1.0版本只能保存药品。后续会升级更多功能，如需帮助或需要更多功能请在此留言。","link":"/idevil/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Homebrew命令","text":"Homebrew完美卸载软件及其依赖包brew tap beeftornado/rmtreebrew rmtree git #卸载git及其依赖安装包brew cleanup","link":"/uncategorized/homebrew.html"},{"title":"CloudKit 问题集锦","text":"字段识别Apple Developer CloudKit Class String(list) NSArray String NSString Asset CKAsset Bytes NSData Date/Time NSDate Double NSNumber Int(64) NSNumber Location CLLocation Reference CKReference 报错Field ‘___createTime’ is not marked sortable确保CloudKit的Schema中Indexes设置Sortable","link":"/uncategorized/cloudkit_question.html"},{"title":"MKit API数据库文档","text":"MKit APi 数据库说明文档 药盒 box 字段 名称 类型 限制 必填项 注释 name 名称 VARCHAR 无 是 药材名称 icon 图片 BLOB 最大64K 是 药材图片 instructionID 说明书 TINYINT 是 药材 meterials 字段 名称 类型 限制 必填项 注释 name 药材名称 VARCHAR 无 是 药材名称 icon 药材图片 BLOB 最大64K 是 药材图片 category 药材类别 TINYINT 0或1 是 0中药或1西药 企业 enterprise 字段 名称 类型 限制 必填项 注释 name 企业名称 VARCHAR 无 是 企业名称 icon 企业图片 BLOB 最大64K 是 企业图片 site 生产地址 VARCHAR 无 是 企业生产地址 logonSite 注册地址 VARCHAR 无 是 注册地址 phone 生产电话 VARCHAR 无 是 生产电话 fax 传真 VARCHAR 无 是 传真 webSite 网址 VARCHAR 无 是 网址 说明书 instructions 字段 名称 类型 限制 必填项 注释 name 名称 VARCHAR 无 是 名称 icon 说明书图片 BLOB 最大64K 是 说明书图片 category 类别 TINYINT 0或1 是 0中药或1西药 otc 处方药 TINYINT 0或1 是 0处方药或1甲类非处方药，2乙类非处方药 components 成分 VARCHAR 无 是 traits 性状 VARCHAR 无 是 adaptation 适应症 VARCHAR 无 是 reactions 不良反应 VARCHAR 无 是 no 禁忌 VARCHAR 无 是 attention 注意事项 VARCHAR 无 是 enterprisID 生产企业 VARCHAR 无 是","link":"/Swift/Vapor/APP/Mkit/mkit_api_data_doc.html"},{"title":"Swift CoreData @FetchRequest","text":"@FetchRequest( entity: UserInfo.entity(), sortDescriptors: [ NSSortDescriptor(keyPath: \\UserInfo.name, ascending: true) ], predicate: NSPredicate(format: \"name == %@\", \"Lilei\"))) var userinfoes: FetchedResults&lt;UserInfo&gt; NSPredicate 描述了一个过滤器，我们将使用它来决定显示哪些结果 NSPredicate(format: \"name == %@\", \"LiLei\") NSSortDescriptor 告诉我们要在哪个字段上进行排序，以及我们要它递增还是递减 NSSortDescriptor(keyPath: \\UserInfo.name, ascending: true)","link":"/Swift/Core-Data/FetchRequest/swift_coredata_fetchrequest.html"},{"title":"MKit-API接口文档","text":"MKit APi 接口说明文档 接口药材获取列表根据版本获取药材列表，符合版本情况，则返回Redis缓存数据，否则更新缓存，并下放数据 接口类型 GET 请求参数 字段 类型 名称 必填项 功能 AppVersion Int APP版本号 是 当前客户端版本 DataVersion Int 数据版本号 是 高等于缓存版本不下放数据，低于缓存版本返回数据 返回字段 返回字段 字段类型 说明 status Int 100 = 请求成功 message String 描述 version Int 版本号 返回事例 不下放数据 { \"status\": 101, \"version\": 20190810, \"message\": \"无需更新数据\"} 下放数据 { \"status\": 100, \"message\": \"请求成功\", \"data\": [ { \"id\": 1, \"icon\": \"Meterial icon:Optional(1)\", \"name\": \"Meterial name:Optional(1)\", \"category\": 1 } ], \"version\": 20190810} 生产企业获取列表","link":"/Swift/Vapor/APP/Mkit/mkit_api_doc.html"},{"title":"SwiftUI  Picker","text":"Picker 会根据平台显示所要展示的效果 Pickerstruct Picker&lt;Label, SelectionValue, Content&gt; where Label : View, SelectionValue : Hashable, Content : View 用法Picker基础用法var strengths = [\"男\", \"女\"]@State private var selectedStrength = 0var body: some View { Form { Picker(selection: $selectedStrength, label: Text(\"Strength\")) { ForEach(0 ..&lt; strengths.count) { Text(self.strengths[$0]).tag($0) } } }}// Core Data中用法Button(action: ({ let user = User(context: self.managedObjectContext) user.name = self.selectedStrength do { try self.managedObjectContext.save() } catch { print(error) }})) Picker中使用自定义结构体@ObservedObject var frequencies = DrugUserInfoes() //吃药频率var body: some View { Form { Picker(\"服药频率\", selection: $frequencies.drugEatInfoes) { ForEach(DrugUserInfoes.DrugEatInfoes.allCases, id: \\.self) { season in Text(season.rawValue).tag(season) } } }}class DrugUserInfoes: ObservableObject { enum DrugEatInfoes: String, CaseIterable { case day1eat1 = \"一天一次\" case day1eat2 = \"一天两次\" } //设置默认选择项 @Published var drugEatInfoes = DrugEatInfoes.day1eat2}// Core Data中用法Button(action: ({ let eatInfo = EatInfo(context: self.managedObjectContext) eatInfo.frequency = self.frequencies.drugEatInfoes.rawValue do { try self.managedObjectContext.save() } catch { print(error) }})) Picker中使用API Json@ObservedObject var networkingManager = NetworkingManager() //读取API数据var body: some View { Form { //请求API返回药品列表 Picker(selection: $selection, label: Text(\"药品名称\").bold()) { ForEach(0 ..&lt; networkingManager.dataList.data.count, id: \\.self) { Text(self.networkingManager.dataList.data[$0].name).tag($0) } } }}// Core Data中用法Button(action: ({ let eatInfo = EatInfo(context: self.managedObjectContext) eatInfo.name = self.networkingManager.dataList.data[self.selection].name do { try self.managedObjectContext.save() } catch { print(error) }})) DatePickerSwiftUI的DatePicker视图类似UIDatePicker，并带有各种各样的选择来控制它的外观和运行。 像所有存储值的控件一样，它确实需要绑定到应用程序中的某种状态。 例如，这创建了一个绑定到生成日期属性的日期选项，允许用户先选择任何日期，然后显示日期选项的值，因为该选项设置时即可： struct ContentView: View { var dateFormatter: DateFormatter { let formatter = DateFormatter() formatter.dateStyle = .long return formatter } @State private var birthDate = Date() var body: some View { VStack { DatePicker(selection: $birthDate, in: ...Date(), displayedComponents: .date) { Text(\"Select a date\") } Text(\"Date is \\(birthDate, formatter: dateFormatter)\") } }} 在其他控件中的用法翻页选择 嵌套在Form中，就会有NavigationView的显示效果 var users1 = [\"男\", \"女\"]var body: some View { Form { Picker(selection: $gender, label: Text(\"性别\").bold()) { Text(\"女\").tag(1) Text(\"男\").tag(2) }.pickerStyle(SegmentedPickerStyle()) }} 标准样式 .pickerStyle DefaultPickerStyle PopUpButtonPickerStyle（macOS） RadioGroupPickerStyle（macOS） SegmentedPickerStyle（macOS、iOS、tvOS、Mac Catalyst） WheelPickerStyle（iOS、watchOS、Mac Catalyst） SegmentedPickerStyle 横向选择 var users1 = [\"男\", \"女\"]var body: some View { VStack { Picker(selection: $gender, label: Text(\"性别\").bold()) { Text(\"女\").tag(1) Text(\"男\").tag(2) }.pickerStyle(SegmentedPickerStyle()) }} iOS效果 macOS效果tvOS效果Mac Catalyst效果WheelPickerStyle 竖向选择 var users1 = [\"男\", \"女\"]var body: some View { VStack { Picker(selection: $gender, label: Text(\"性别\").bold()) { Text(\"女\").tag(1) Text(\"男\").tag(2) }.pickerStyle(WheelPickerStyle()) }} iOS效果 macOS效果tvOS效果Mac Catalyst效果PopUpButtonPickerStyleRadioGroupPickerStyle其他.labelsHidden() 隐藏标签 这仍然创造了标签，但现在却没有显示出来。 因此，您可以将Picker放入VStack中，并添加您自己选择的标签。提示：如果你想要隐藏所有标签，你可以将标签 .labelsHidden() 修改符应用到VStack或你所使用的最外层容器中。","link":"/SwiftUI/swiftui_picker.html"},{"title":"Terminal（终端）使用SS代理进行连接","text":"SS APP一般是Web代理，终端无法使用，需要单独配置代理 Shadowsocks 设置打开HTTP代理设置菜单，查看SS 的HTTP 代理端口，一般为1087 编辑zshrc文件添加以下内容到 zshrc 中 alias proxy-on='export http_proxy=127.0.0.1:1087;export https_proxy=$http_proxy'alias proxy-off='unset http_proxy;unset https_proxy' 保存退出生效配置 source ~/.zshrc 开启 proxy-on 关闭 proxy-off 只在当前标签页生效，重新打开终端或新标签页需要重新执行 proxy-on 检查对比开启前后的IP变化 curl cip.cc IP : 27.198.***地址 : 中国 山东 济宁运营商 : 联通数据二 : 山东省济宁市 | 联通数据三 : 中国山东省济宁市 | 联通URL : http://www.cip.cc/27.198.*** IP : 128.1.***地址 : 美国 加利福尼亚州 洛杉矶运营商 : zenlayer.com数据二 : 美国数据三 : 美国加利福尼亚洛杉矶 | 层峰网络URL : http://www.cip.cc/128.1.*** 注意不要连续curl，响应时间会有延迟","link":"/APP/Terminal/Shadowsocks/terminal_ss.html"},{"title":"URLSession","text":"httpBody自定义格式func postHttp(params: [String:Any]) -&gt; Void { request.httpBody = try! JSONSerialization.data(withJSONObject: params, options: .prettyPrinted)}//使用let params = [\"id\":dataApiDrugs.descriptionID] as [String:Any]self.postHttp(url: \"https://siboxapi.herokuapp.com/description/select\", params: params) 使用模型func postHttp(params: PostParm) -&gt; Void { request.httpBody = try! JSONSerialization.data(withJSONObject: params, options: .prettyPrinted) do { request.httpBody = try JSONEncoder().encode(parm) } catch { return }}//api接口参数结构struct PostParm: Codable { let id: Int16}//使用let myParam = PostParm(id: dataApiDrugs.descriptionID)self.postHttp(url: \"https://siboxapi.herokuapp.com/description/select\", params: myParam)","link":"/uncategorized/URLSession.html"},{"title":"Windows下MySql安装","text":"MySql下载 去MySql官网下载MySql Zip文件解压安装包，记住解压路径，后面的文件路径以实际路径为准进入mysql目录，更改my-default.ini文件名为my.ini，在[mysqld]下面添加一行编码： basedir = D:/mysql-5.6.25-winx64/datadir = D:/mysql-5.6.25-winx64/data/tmpdir = D:/mysql-5.6.25-winx64/temp/character-set-server = utf8user=mysql 注意路径中的反斜杠，不要用Windows的正斜杠 配置环境变量在环境变量里配置系统变量，新建MYSQL_HOME变量，添加Path记录 MYSQL_HOME=C:\\Program Files\\mysql\\mysql-5.6.25-winx64Path=%MYSQL_HOME%/bin 注意环境变量的配置规则 安装MySQL管理员执行CMD，进入MySQL的bin目录 mysqld --install MySQL --defaults-file=\"my.ini\" “Win+R”组合键，查找“regedit”，打开注册表，找到路径 HKEY_LOCAL_MACHINE - SYSTEM - CurrentControlSet - services - mysql 找到其中的ImagePath，将值改为 “D:\\mysql-5.6.25-winx64\\bin\\mysqld” –defaults-file=”D:\\mysql-5.6.25-winx64\\my.ini” MySQL 此时MySql已经安装好了，可以直接启动了 MySQL服务的启动、停止与卸载启动: net start MySQL停止: net stop MySQL卸载: sc delete MySQL","link":"/APP/MySQL/windows_mysql_install.html"},{"title":"Xcode如何进行无线真机调试","text":"Xcode 进行真机调试 登陆Xcode Team 链接手机Xcode菜单导航栏，选择 Window - Devices and Simulators 数据线链接手机，验证后会自动出现该手机信息，选中Connect via network 使手机可以无线测试 测试iOS工程中，选择该手机调试","link":"/uncategorized/xcode_iphone_test.html"},{"title":"CentOS7下MySQL源码安装","text":"CentOS下MySQL源码安装 卸载系统自带的MySQL# 卸载系统默认安装包yum remove mysql mysql-server mysql-libs compat-mysql51# 删除原始文件夹rm -rf /var/lib/mysqlrm /etc/my.cnf# 检查一下是否还有残留，有则删除rpm -qa|grep mysql MySQL源码安装MySQL下载 下载地址，选择最下面“Generic Linux”版本 http://dev.mysql.com/downloads/mysql/5.6.html#downloads 解压编译，安装工具包tar xvf mysql-5.6.30.tar.gzcd mysql-5.6.30yum -y install make gcc gcc-c++ cmake bison-devel ncurses-devel libaio bison libaio libaio-devel perl-Data-Dumper net-tools 编译，注意cmake \\后面操作都带有“-”符号 cmake \\-DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\-DMYSQL_DATADIR=/usr/local/mysql/data \\-DSYSCONFDIR=/etc \\-DWITH_MYISAM_STORAGE_ENGINE=1 \\-DWITH_INNOBASE_STORAGE_ENGINE=1 \\-DWITH_MEMORY_STORAGE_ENGINE=1 \\-DWITH_READLINE=1 \\-DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock \\-DMYSQL_TCP_PORT=3306 \\-DENABLED_LOCAL_INFILE=1 \\-DWITH_PARTITION_STORAGE_ENGINE=1 \\-DEXTRA_CHARSETS=all \\-DDEFAULT_CHARSET=utf8 \\-DDEFAULT_COLLATION=utf8_general_ci 编译成功，执行安装 MySQL5.7版本需增加“-DDOWNLOAD_BOOST=1 -DWITH_BOOST=/usr/local/boost” 如果编译出现问题，执行“rm CMakeCache.txt”，便可重新编译 make &amp;&amp; make install 创建用户# 创建用户组和用户groupadd mysqluseradd -g mysql mysql# 赋予权限chown -R mysql:mysql /usr/local/mysql# 链接配置文件ln -s /usr/local/mysql/bin/mysql /usr/bin 有时候执行service mysql start命令报错env: /etc/init.d/mysql:权限不够问题解决办法：执行下面的语句chmod a+wrx /etc/init.d/mysql 实例安装进入安装包的路径cd /usr/local/mysql 执行脚本scripts/mysql_install_db --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --user=mysql #####5.7以后版本，执行脚本方法变动如下 #之前版本mysql_install_db是在mysql_basedir/script下，5.7放在了mysql_basedir/bin目录下,且已被废弃./usr/local/mysql/bin/mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data#“–initialize”会生成一个随机密码(~/.mysql_secret)，而”–initialize-insecure”不会生成密码.#–datadir目标目录下不能有数据文件 /usr/local/mysql/my.cnf 为my.cnf默认路径 添加端口到防火墙firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload 添加服务，拷贝服务脚本到init.d目录，并设置开机启动cp support-files/mysql.server /etc/init.d/mysqlchkconfig mysql on 启动MySQLservice mysql start","link":"/APP/MySQL/centos_mysql_install.html"},{"title":"Github修改下载Host","text":"github上面有许多公开项目资源有的下载很慢，有时候挂VPN也解决不了；这时候需要修改git clone 使用的域名IP，解决办法可以从git clone的域名入手，实际上用git clone下载项目文件时使用的域名是http://github.global.ssl.fastly.net ，而非http://github.com/ 。因此，我们可以修改本地的host文件，在host文件中增加域名及域名解析对应的ip，给该域名指定ip。 利用第三方DNS域名解析网站，查询响应ip，常用的第三方DNS域名解析网站如http://tool.chinaz.com/dns ，如图 不同地方对应该域名的响应ip不一样，网页解析速度也就不一样。选择TTL值最小的ip即可。 参考文章Github上项目文件上传、下载速度慢的问题及解决方法","link":"/Git/Github/github_host.html"},{"title":"Hexo 生成 sitemap 站点地图","text":"百度+谷歌搜索博客 创建站点地图文件站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 先安装一下，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在博客目录的config.yml中添加如下代码Plugins:- hexo-generator-baidu-sitemap- hexo-generator-sitemapbaidusitemap: path: baidusitemap.xmlsitemap: path: sitemap.xml 在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了让百度收录我们的博客 参考文章生成sitemap站点地图","link":"/Hexo/hexo_sitemap.html"},{"title":"Sketch 快捷键","text":"a：尺寸模版工具栏","link":"/APP/Sketch/Sketch_key.html"},{"title":"设计HTTP API的最佳实践","text":"Request Method当客户端向服务器发起HTTP请求的时候，请求的Header中会有一个字段叫Request Method，也叫做HTTP verb，不同的HTTP verbs表达了不同的HTTP请求意图，而我们常用的，有下面这几种： GET：表示客户端需要请求服务器的某个资源。简单来说，就是当我们需要给用户显示某些保存在服务器上的内容时，都会向服务器发起GET请求 POST：表示向服务器提交数据，例如用户注册时填写的信息、登录时填写的用户名/密码等。简单来说，就是当我们需要根据用户输入在服务器上创建新记录的时候，都会向服务器发起POST请求 PUT：表示根据用户提供的内容，修改服务器上的特定资源；PUT请求修改要求提供的数据是全量的，例如当我们修改某条数据库记录时，使用PUT请求，应该包含这条记录的所有字段，这种修改更像是覆盖 PATCH：使用PATCH请求提交的内容则是有针对性的，只要提供需要的部分就好了 Naming conventions了解了HTTP verbs之后，我们来看设计HTTP APIs时应遵信的一些命名规范。其中，最重要的一个大原则就是，永远使用名词表示API管理的资源。 文档类型的API：用于访问服务器上的某一个文件，或者某一条数据记录，因此，我们应该以单数名词结尾，或者以一个复数名词加上一个与之有关的值,例如：https://api.soyl.com/episodes/{id}https://api.soyl.com/accounts/admin 集合类型的API：用于访问服务器上的某一类内容，例如数据库中的某个记录集合。定义这一类API的时候，除了在URL中使用复数名词之外，整个URL中还应该包含访问到这个集合时用到的每一个资源的名称https://api.soyl.com/series/{id}/episodes 集合的筛选的API：如果我们要让API支持集合的筛选，就不要使用/来设置条件了，而是应该在URL末尾添加条件查询。例如，为了得到所有按月订阅的会员，我们可以这样：https://api.soyl.com/users?sub-type=month 和控制行为有关的API：这是为数不多的，我们会在URL中使用动词的例子。例如，为了结算用户的购物车，在结尾，我们使用了/cart/check这样的形式，这很类似面向对象编程中的访问cart对象的checkout方法的感觉。一旦看到这种形式的API，我们就知道它会在服务器执行某个动作，而不是管理某些资源。https://api.soyl.com/users/{id}/cart/checkout 再来看个例子，如果要播放某个视频，我们可以这样：https://api.boxue.io/series/{id}/episodes/{id}/play 这个API可以分几段来理解： 第一段是/series/{id}，我们可以把它想象成是一个叫做series的方法，它接受一个参数id，并返回一个集合，包含了改系列所有的视频； 第二段是/episodes/{id}，类似的，我们使用id作为索引，访问到了集合中的某个视频对象； 第三段是/play，可以理解成是调用了视频对象的play方法执行播放；这样，整个URL的含义就很清楚了。 API的细节 不要在URL中使用，很难只用一个单词来描述URL中的一个环节，这时，就可以使用-来分割多个单词，而不是用 始终坚持使用小写字母，RFC 3986约定了：对于URL来说，SCHEME和HOST部分是不区分大小写的；而其余的部分是区分大小写的 不要在URL中包含扩展名","link":"/Swift/http_api.html"},{"title":"基于MVVM构建App工程结构","text":"App的工程结构首先，我们从工程结构开始。构成整个项目的文件，一共可以分成五大类，分别是： A - 和App启动相关的代码、配置以及资源； B - 和UI的显示以及交互相关的代码； C - 对UIKit的公共扩展； D - 存储数据的model； E - 使用的第三方库； 接下来，我们可以新建一个Single View Application项目，基于它来构建整个工程。 A对于A这部分，主要包含App启动相关的代码、配置以及资源： AppDelegate：在这里我们定义App的启动流程； Info.plist：在这里我们配置App的行为； LaunchScreen.storyboard：在这里我们定义App的启动屏幕； Localizable.strings：这里我们定义支持多语言的各种翻译； 这是初始Single View Application模板被删减后的部分 可以看到，我们删掉了默认的Main.storyboard，并在Info.plist中去掉了Main storyboard file base name的配置。在整个App里，我们将使用代码来实现UI。 AppDelegate.swift中是App的入口，由于删掉了Main.storyboard，我们将专门准备一节来讨论相关的内容。 BxLaunchScreen.storyboard是App的启动UI，别忘了在Boxue Target中也设置成对应的文件： Localizable.strings则是多语言文件，同样，我们会单独用一节来分享Boxue App中使用的多语言处理方法。 B / C / D对于B / C / D这三部分，由于它们彼此独立，为了可以同步开发，并让C和D的代码可重用，我们把这三部分内容定义成了三个framework。其中： Boxue_iOS里是和UI的显示以及交互相关的代码； BoxueUIKit是整个项目中会用到的对UIKit的公共扩展； BoxueDataKit是整个项目的数据存储以及访问接口，也可以理解为是App的View Model以及Model； 在项目的Targets列表中，可以看到app以及这三个framework，如果你要自己动手练习，只要在自己的项目中，点击Targets列表左下角的+，然后选择添加CocoaTouch framework就好了。 B是Boxue_iOS，这个framework中都是处理UI显示以及交互的代码，它的使用者，是刚才我们提到的Boxue Target。这里，iOSApp group包含了全部iOS相关的实现。 在这个group里，处在根目录的文件有三类： 一个是BoxueAppDepedencyContainer.swift，它主要处理对象的初始化工作，稍后我们会专门用几个小节讨论依赖注入和容器的话题； 一类是处理App从启动阶段到注册前交互的View Controllers； 还有一类是和View Controller对应的View； 遵循这三个分类，我们可以进一步在这个group中创建sub group，例如上图中的PreSignIn group就表示所有处理登录前UI显示和交互的View Controllers。而等我们开发到后期的时候，登录后UI的处理也可以采用同样的模式。 同样，大家现在只要知道这些文件的功能就好，大可不必关心其中的实现，我们会在后面的内容中专门讲述代码的细节。 CBoxueUIKit这个framework，可以理解为是我们的UIKit工具库，包含了项目中使用的对UIKit的各种扩展、工具类和工具函数。它的使用者，则是Boxue_iOS Target。 在这个group里，Reusable / UIKit这个sub group中，是对UIKit的扩展，我们可以按照功能分类继续在其中创建sub group，例如我们当前的： Style group是对样式相关类的扩展； Nibless group是为了纯代码实现View Controller对各种View Controllers以及View类的扩展； 理解了这个思路之后，我们就可以用这种方法，把这个framework的各种接口组织起来了。慢慢地，我们开发的功能越多，这个framework功能就会越丰富。当我们切换到其它项目中时，也能很方便的重用这些积累起来的功能。D最后一个framework是BoxueDataKit，这个framework包含了两类内容：一类是直接和服务端打交道的Model；另一类，是和View Controllers打交道的View Model。因此，BoxueDataKit中包含了两个sub group，DataLayer表示Model，PresentLayer表示View Model： 但在一个实际的项目中，除了Model和View Model之外，还有一类内容，就是围绕Model要完成的各种业务逻辑。例如，围绕着用户信息的注册、登录和改密码；或者，围绕着用户Session的读取和删除，都属于此类。显然，把处理这些功能的接口直接写在Model里是不合适的。为此，我们还在Model group中新建了一个Repositories的sub group，这里，就是围绕着Model要定义的各种业务逻辑接口，例如Remote group表示所有的远程访问API，Persistence group*表示本地持久化存储数据API等等。当然，我们现在只要知道这样做的意图就好了，完全没必要关心代码的细节。 而相比DataLayer，PresentLayer的内容倒是简单很多。基本上，App的每一屏，都会对应一个View Model文件。并且，功能相关的一组View Models，我们还可以给它们创建一个公共的subgroup。例如用于支持引导用户注册、登录或直接浏览功能的View Model，就统一放在了Guide group里，这样方便维护。 E对于项目中使用的第三方库，我们选择了Carthage。在项目根目录的Cartfile中，作为开始，我们引入了以下内容： github &quot;mxcl/PromiseKit&quot; ~&gt; 6.4.0github &quot;onevcat/Kingfisher&quot; ~&gt; 4.9.0github &quot;ReactiveX/RxSwift&quot; ~&gt; 4.3.0 其中： PromiseKit用于简化异步操作的代码； Kingfisher用于缓存下载的图片 RxSwift用于管理App中的事件 作为开始，暂时就包含这3个，以后随着开发用到，我们再添加就好了。添加完成后，我们要在项目根目录执行： carthage update --platform iOS --no-use-binaries 来安装所有的依赖关系，这里，–no-use-binaries很重要，如果不带这个参数直接安装Carthage默认的framework，当你使用LLDB调试的时候，就会出现类似error: Couldn’t IRGen expression这样的提示，这是我们要注意的地方。 完成后，在TARGETS列表中，选中Boxue，在General tab的最底部就会看到，Embeded binary包含了我们自己创建的三个frameworks，Linked Frameworks and Libraries则包含了我们自己创建的三个frameworks以及通过Carthage引入的三个frameworks： 接下来，保持Boxue TARGET选中，切换到Build Phases tab，在这里，点击+，选择New Run Script Phase，这时，Xcode就会要求我们填写一些东西。 其中，执行的命令，我们写： /usr/local/bin/carthage copy-frameworks Input Files我们写： $(SRCROOT)/Carthage/Build/iOS/Kingfisher.framework$(SRCROOT)/Carthage/Build/iOS/RxSwift.framework$(SRCROOT)/Carthage/Build/iOS/RxCocoa.framework$(SRCROOT)/Carthage/Build/iOS/PromiseKit.framework Output Files我们写： $(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/Kingfisher.framework$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/RxSwift.framework$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/RxRocoa.framework$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/PromiseKit.framework 完成后，看起来是这个样子的： 这个命令的作用就是把之前我们用Carthage引入的第三方库在打包的时候，拷贝到特定目录。","link":"/Swift/mvvm_app.html"},{"title":"MyEclipse2015启动Tomcat中项目时报错HttpSession出错","text":"MyEclipse2015启动Tomcat中项目时报错HttpSession出错 Tomcat中项目时报错HttpSession出错，如下 org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/mj_oto_edus_auto_new]] ************************************Caused by: java.lang.NoClassDefFoundError: HttpSession ************************************Caused by: java.lang.NoClassDefFoundError: HttpSessionBindingEvent ************************************ 百度搜索HttpSession的信息,百科对它的简单介绍是Java的一个接口。 HttpSession是Java平台对session机制的实现规范，因为它仅仅是个接口，具体到每个web应用服务器的提供商，除了对规范支持之外，仍然会有一些规范里没有规定的细微差异。 HttpSession (Java EE 5 SDK)发现原来他是在Java EE 5中，于是在MyEclipse中Libraries中加上“JavaEE 5.0 Generic Library”，继续执行项目，项目继续报错，缺少jstl。查看“JavaEE 5.0 Generic Library”发现其中只有一个“javaee.jar”,于是在MyEclipse的目录中找到“javaee.jar”所在的目录，发现其中有个文件README.txt This folder contains libraries obtained from the Sun JEE5 Referene SDK. http://java.sun.com/javaee/downloads/index.jspThe license for these 3 jar libraries is also contained in this folder.The JSF 1.2 implementation files (jsf-impl.jar, jsf-api.jar)were obtained from: https://javaserverfaces.dev.java.net/files/documents/1866/52042/jsf-1.2_04-b07-FCS.zipThe JSTL 1.2 implementation files: (jstl-1.2.jar)were obtained from: https://maven-repository.dev.java.net/repository/jstl/jars/jstl-1.2.jar 发现原来还少jsf-impl.jar, jsf-api.jar，jstl-1.2.jar这三个文件于是继续在Library中添加JSF Mojarra 1.2_04 Libraries,JSTL 1.2 Library两项。 JSF Mojarra 1.2_04 Libraries 包含jsf-impl.jar, jsf-api.jarJSTL 1.2 Library 包含jstl-1.2.jar 然后运行Tomcat，问题解决 我是在MyEclipse 2015使用的，其他版本的不清楚，也可以直接下载到本地，加载到项目中。 百度网盘链接: http://pan.baidu.com/s/1gfNhWcz 密码: r39f","link":"/APP/MyEclipse/MyEclipse2015_HttpSession_error.html"},{"title":"Loadrunner Error问题处理","text":"Loadrunner报错，处理方法记录 Error -26488: Could not obtain information about submitted file脚本中的上传操作回访时报错Error -26488是因为Loadrunner默认文件上传位置为当前脚本所在的目录。 解决方法：将上传的文件放到脚本的目录下","link":"/APP/Loadrunner/Loadrunner_Error.html"},{"title":"Sketch 插件整理","text":"Sketch measure标记尺寸 快捷键：Ctrl + Cmd + B Runner快速查找组件 快捷键：Cmd + ‘ Auto-Layout组件位置 安装好之后，选中一个对象，Auto Layout就会出现在inspector的右下角","link":"/APP/Sketch/Sketch_Plugins.html"},{"title":"MyEclipse2015项目报错Failed while installing Dynamic Web Module 2.5","text":"错误信息Failed while installing Dynamic Web Module 2.5解决方法 使用MyEclipse 2015从SVN检出代码后，项目无法放到Tomcat中，提示错误信息 Failed while installing Dynamic Web Module 2.5 解决方法是在MyEclipse中 ，右键项目选择“Properties”，找到“Project Facets”项 找到 Dynamic Web Module ，把他后面的3.0改成 2.5 再执行添加项目操作就可以将项目导入Tomcat中了。","link":"/APP/MyEclipse/MyEclipse2015_Failed_2.5.html"},{"title":"CentOS7下Redis安装","text":"Redis安装 下载Redis http://redis.io/ 下载最新版的Redis 也可以使用wget直接下载redis wget http://download.redis.io/releases/redis-3.2.0.tar.gz 安装Redis解压Redis tar zxvf redis-3.2.0.tar.gzmv redis-3.2.0 rediscd redis 编译安装 yum -y install make gcc-c++ cmake bison-devel ncurses-devel libaio bison libaio libaio-devel perl-Data-Dumper net-toolsmake 出现下面结果表示成功 Hint: To run ‘make test’ is a good ideamake[1]: Leaving directory `/opt/redis-3.2.0/src’ make install 出现下面结果表示成功 Hint: To run ‘make test’ is a good idea INSTALL install INSTALL install INSTALL install INSTALL install INSTALL installmake[1]: Leaving directory `/opt/redis-3.2.0/src’ cd src &amp;&amp; make install 出现下面结果表示成功 Hint: To run ‘make test’ is a good idea INSTALL install INSTALL install INSTALL install INSTALL install INSTALL instal 此时Redis已经安装成功，直接执行redis-server就可以启动redis Redis使用脚本当Redis多实例启动时，没有脚本需得启动多个redis.conf文件，比较麻烦，使用脚本启动比较方便。 脚本步骤1. 在/etc/rc.d/init.d/目录下新建redis文件，将脚本内容拷贝进去 2. chkconfig --add redis #注册服务 3. chkconfig --level 345 redis on #指定服务在3、4、5级别运行 4. systemctl daemon-reload 5. 多端口时新建redis.conf文件命名方法建议为“redis-6381.conf”这种格式以便跟脚本中对应，如以其他命名，脚本需做相应更改。脚本参数 service redis -p [port] [start|stop|status|restart]参数说明： -p [port] : 指定redis实例的端口，用于多实例的服务器 start：启动指定端口的Redis服务 stop：停止指定端口的Redis服务 status：进程状态 restart：先关闭Redis服务,再启动Redis服务注：不指定端口时，脚本默认指定启动6379端口的redis 使用示例 service redis -p 6381 start #启动6381端口实例的redis /etc/init.d/redis start #默认启动6379端口实例的redis脚本内容#!/bin/bash#chkconfig: 2345 55 25#description: Starts,stops and restart the redis-server#Ver:1.1 #Write by ND chengh(200808)#usage: ./script_name -p [port] {start|stop|status|restart}# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check networking is up.[ \"$NETWORKING\" = \"no\" ] &amp;&amp; exit 0RETVAL=0REDIS_PORT=6379PID=if [ \"$1\" = \"-p\" ]; then REDIS_PORT=$2 shift 2fiREDIS_DIR=\"/data/redis-3.2.0\"REDIS=\"${REDIS_DIR}/src/redis-server\"PROG=$(basename $REDIS)CONF=\"${REDIS_DIR}/port/redis-${REDIS_PORT}.conf\"if [ ! -f $CONF ]; then if [ -f \"${REDIS_DIR}/port/redis.conf\" ];then CONF=\"${REDIS_DIR}/port/redis.conf\" else echo -n $\"$CONF not exist.1\";warning;echo exit 1 fifiPID_FILE=`grep \"pidfile\" ${CONF}|cut -d ' ' -f2`PID_FILE=${PID_FILE:=/var/run/redis.pid}LOCKFILE=\"/var/lock/subsys/redis-${REDIS_PORT}\"if [ ! -x $REDIS ]; then echo -n $\"$REDIS not exist.2\";warning;echo exit 0fistart() { echo -n $\"Starting $PROG: \" $REDIS $CONF RETVAL=$? if [ $RETVAL -eq 0 ]; then success;echo;touch $LOCKFILE else failure;echo fi return $RETVAL}stop() { echo -n $\"Stopping $PROG: \" if [ -f $PID_FILE ] ;then read PID &lt; \"$PID_FILE\" else failure;echo; echo -n $\"$PID_FILE not found.\";failure;echo return 1; fi if checkpid $PID; then kill -TERM $PID &gt;/dev/null 2&gt;&amp;1 RETVAL=$? if [ $RETVAL -eq 0 ] ;then success;echo echo -n \"Waiting for Redis to shutdown ..\" while checkpid $PID;do echo -n \".\" sleep 1; done success;echo;rm -f $LOCKFILE else failure;echo fi else echo -n $\"Redis is dead and $PID_FILE exists.\";failure;echo RETVAL=7 fi return $RETVAL}restart() { stop start}rhstatus() { status -p ${PID_FILE} $PROG}hid_status() { rhstatus &gt;/dev/null 2&gt;&amp;1}case \"$1\" in start) hid_status &amp;&amp; exit 0 start ;; stop) rhstatus || exit 0 stop ;; restart) restart ;; status) rhstatus RETVAL=$? ;; *) echo $\"Usage: $0 -p [port] {start|stop|status|restart}\" RETVAL=1esacexit $RETVAL 注意你安装Redis的目录，要对脚本中目录做出相应更改。","link":"/APP/Redis/CentOS7_Redis_install.html"},{"title":"MacOS 10.12 终端命令行下使用Shadowsocks","text":"Shadowsocks-NG有一个新的Shadowsocks的客户端叫 Shadowsocks-NG 解决了一个长久以来的痛点，Shadowsocks没有HTTP代理，导致我们需要使用polipo等软件进行协议转换 现在其在1087端口提供了http代理服务(http代理代理设置选项)，我们可以通过在命令行直接设置代理，来使用SS服务了 #开启代理export http_proxy=127.0.0.1:1087export https_proxy=127.0.0.1:1087#关闭代理unset http_proxyunset https_proxy 配置一个别名方便启动 vim ~/.bash_profile#orvim ~/.zshrc 在文件内加入 #Custom Add not Systemalias proxy-on='export http_proxy=127.0.0.1:1087;export https_proxy=$http_proxy'alias proxy-off='unset http_proxy;unset https_proxy' 就可以在命令行内通过 proxy-on 和 proxy-off 来开启关闭代理 sudo操作怎么办以上快捷启动配置只能在User的命令行里进行使用，如果想对sudo操作挂proxy，需要先使用命令 sudo -s 进入bash 3.2# 然后手动设置","link":"/APP/Shadowsocks/macos10_12_shadowsocks.html"},{"title":"MySQL命令学习记录","text":"工作中用到的一些MySQL命令，记录下方便日后查询 用户登录命令本地登录mysql -u root -p 远程登陆Mysql -P 端口号 -h mysql主机名\\ip -u（用户） -p（密码） 创建用户命令创建本地用户命令 grant all privileges on *.* to admin@localhost identified by 'password' with grant option 创建远程用户grant all privileges on *.* to admin@\"%\" identified by 'password' with grant option 查询命令查看当前编码show variables like 'character%'; 查看当前数据库类型show variables like 'character%'; 查看死锁状态show status like 'table%';","link":"/APP/MySQL/mysql_command.html"},{"title":"MySQL参数学习","text":"MySQL参数学习 [mysqld_safe]pid-file=/usr/mysql/run/localhost.pid 单独设置一个pid的存放地址，以保护不被误删 [mysql]port=3306 端口号 default-character-set=utf8 编码格式 no-auto-rehash 自动补全，如同linux下的table键 [mysqld]目录basedir=/usr/mysql MySQL主目录 datadir=/usr/data mysql 全局数据文件及结构的存放位置；表数据（包括innodb引擎），索引，日志（除非单独设置）等文件都会存放在这里。 tmpdir=/tmp 创建临时表文件目录 lc_messages=en_US 生成文件的语言环境，建议为en_US lc_messages_dir=/u02/mysql/share 语言环境文件路径 socket=/u02/mysql/run/mysql.sock 套字文件，保护不被误删，每次重启mysql都会重新创建，在[client]也要设置相同位置 日志错误日志log_error=/u02/mysql/log/localhost.log 指定Log错误文件路径 慢查询日志slow_query_log_file=/u02/mysql/log/slow.log 指定慢查询日志文件路径 slow_query_log=on 开启慢查询日志“【OFF】是关闭日志”，用来分析执行时间较长的SQL long_query_time=2 设置慢查询日志多长时间后才会记录，单位为s log_queries_not_using_indexes=on 设置是否把没有使用索引的SQL放到慢查询日志中,off是没有开启,on是开 普通日志general_log=off 是否开启普通日志，此参数开启后会记录MySQL所有执行sql记录，包括错误的sql，除特殊情况不建议开启 general_log_file=/u02/mysql/log/general.log 普通日志文件位置 Innodb设置innodb_data_home_dir=/u02/data innodb引擎的共享表空间数据文件根目录 innodb_data_file_path=ibdata1:512M;ibdata2:16M:autoextend 指定了所有InnoDB数据文件初始大小分配，最大分配以及超出起始分配界线时是否应当增加文件的大小，位置由innodb_data_home_dir指定。 innodb_log_group_home_dir=/u02/data 此参数确定日志文件组中的文件的位置，日志组中文件的个数由innodb_log_files_in_group确定，此位置设置默认为MySQL的datadir innodb_log_files_in_group=2 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为2M innodb_buffer_pool_size=200M 如果只用innodb的话可使用70%的可用内存，建议不要超过80%，否则会影响swap innodb_buffer_pool_instances=4 可以开启多少个内存缓冲池，与size搭配使用，大的size建议instances设置为1. innodb_log_file_size=200M 日志文件的大小，此参数越大性能越好，但会增加故障恢复所用时间。依据服务器使用情况设置，推荐设置为0.25 * innodb_buffer_pool_size innodb_log_buffer_size=5M 确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。如果它的值设置太高了，可能会浪费内存 ，它每秒都会刷新一次，因此无需设置超过1秒所需的内存空间。 innodb_flush_log_at_trx_commit=1 参数可供选择0-1-2，0时性能最好，2时安全性最高，默认选中1 innodb_additional_mem_pool_size=20M 设置 InnoDB 存储的数据目录信息和其它内部数据结构的内存池大小，根据项目的InnoDB表的数目相应地增加。参数对系统整体性能并无太大的影响，所以只要能存放需要的数据即可。推荐1/200*buffer_pool","link":"/APP/MySQL/mysql_parm.html"},{"title":"CentOS7下Percona Tookit rmp安装","text":"Percona Tookit下载 CentOS7下默认是没有安装wget命令的，所以先安装wget命令。 yum -y install wget 在Percona官网找到最新版本下载地址（注：要是rpm哦），并复制到下面命令中，也可以直接下载到本地。 https://www.percona.com/downloads/percona-toolkit/ wget https://www.percona.com/downloads/percona-toolkit/2.2.17/RPM/percona-toolkit-2.2.17-1.noarch.rpm 工具安装yum -y install perl-DBI perl-DBD-MySQL perl-Time-HiRes perl-IO-Socket-SSL perl-Digest-MD5 perl-TermReadKey Tookil安装rpm -Uvh percona-toolkit-2.2.17-1.noarch.rpm","link":"/APP/MySQL/centos_tookit_rmp_install.html"},{"title":"Percona Tookit学习手册 - pt-query-digest","text":"pt-query-digest介绍 pt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。 慢查询日志开启方法在mysql的my.ini文件中的mysqld中添加下面参数，然后重启mysql。 slow_query_log_file='/home/mysql/sql_log/mysql-slow.log' //设置慢查询日志位置log_queries_not_using_indexes=on //设置是否把没有使用索引的SQL放到慢查询日志中,off是没有开启,on是开始slow_query_log=on //设置开启慢查询日志,off是没有开启,on是开始long_query_time=1 //查过多少秒的查询设置到慢查询日志中,单位是秒 long_query_time=1设置后，实际上mysql也会把一些小于1S的操作记录下来，主要是因为索引的影响，可以直接把额外的记录忽略。 pt-query-digest语法 pt-query-digest [OPTIONS] [FILES] [DSN] –create-review-table 当使用–review参数把分析结果输出到表中时，如果没有表就自动创建。–create-history-table 当使用–history参数把分析结果输出到表中时，如果没有表就自动创建。–filter 对输入的慢查询按指定的字符串进行匹配过滤后再进行分析–limit限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。–host MySQL服务器地址–user mysql用户名–password mysql用户密码–history 将分析结果保存到表中，分析结果比较详细，下次再使用–history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。–review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用–review时，如果存在相同的语句分析，就不会记录到数据表中。–output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。–since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。–until 截止时间，配合—since可以分析一段时间内的慢查询，格式与since相同。 pt-query-digest使用方法直接使用pt-query-digest /usr/local/mysql/data/slow.log | more 输出到数据库pt-query-digest slow.log -review \\h=127.0.0.1,D=test,p=root,P=3306,u=root,t=query_review \\--create-reviewtable \\--review-history t= hostname_slow 分析最近12小时内的查询pt-query-digest --since=12h slow.log &gt; slow_report2.log 分析指定时间范围内的查询pt-query-digest slow.log --since '2014-04-17 09:30:00' --until '2014-04-17 10:00:00'&gt; &gt; slow_report3.log 分析指含有select语句的慢查询pt-query-digest--filter '$event-&gt;{fingerprint} =~ m/^select/i' slow.log&gt; slow_report4.log 针对某个用户的慢查询pt-query-digest--filter '($event-&gt;{user} || \"\") =~ m/^root/i' slow.log&gt; slow_report5.log 查询所有所有的全表扫描或full join的慢查询pt-query-digest--filter '(($event-&gt;{Full_scan} || \"\") eq \"yes\") ||(($event-&gt;{Full_join} || \"\") eq \"yes\")' slow.log&gt; slow_report6.log 把查询保存到query_review表pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_review--create-review-table slow.log 把查询保存到query_history表pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_history--create-review-table slow.log_20140401pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_history--create-review-table slow.log_20140402 通过tcpdump抓取mysql的tcp协议数据，然后再分析pt-query-digest对于抓包有一定的格式。(-x -nn -q -tttt) tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 &gt; mysql.tcp.txtpt-query-digest --type tcpdump mysql.tcp.txt&gt; slow_report9.log# -s:源端口# -c:抓包的数量 分析binlogmysqlbinlog mysql-bin.000093 &gt; mysql-bin000093.sqlpt-query-digest --type=binlog mysql-bin000093.sql &gt; slow_report10.log 分析general logpt-query-digest --type=genlog localhost.log &gt; slow_report11.log 分析结果详解第一部分# 18.4s user time, 90ms system time, 27.27M rss, 223.26M vsz# Current date: Tue May 10 11:51:19 2016# Hostname: mjjw# Files: /usr/local/mysql/data/mjjw-slow.log# Overall: 29.20k total, 25 unique, 0.41 QPS, 0.51x concurrency __________# Time range: 2016-05-09 16:12:24 to 2016-05-10 11:51:19# Attribute total min max avg 95% stddev median# ============ ======= ======= ======= ======= ======= ======= =======# Exec time 36179s 120us 27s 1s 10s 3s 541us# Lock time 15s 0 454ms 501us 839us 4ms 194us# Rows sent 98.30k 0 1000 3.45 19.46 8.51 0.99# Rows examine 5.22G 0 1.48M 187.54k 1.46M 367.29k 28.75# Query size 46.97M 36 4.46k 1.65k 3.52k 1.46k 363.48 Overall: 总共有多少条查询unique: 唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询，该例为25。Time range: 查询执行的时间范围。total: 总计 min:最小 max: 最大 avg:平均 95%: 把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值。median: 中位数，把所有值从小到大排列，位置位于中间那个数。 第二部分# Profile# Rank Query ID Response time Calls R/Call V/M Item# ==== ================== ================ ===== ======= ===== ===========# 1 0x3C82B414C14E5C06 14439.8524 39.9% 3220 4.4844 9.20 SELECT STUDENT STUDENT_SCHOOL SCHOOL_TABLE STUDENT_ORGAN ORGAN ORDER_FORM T_?_USER_INFO STUDENT_SELL T_?_USER_INFO STUDENT_CONTACT_PERSON LEA_COU_ONE STUDENT_ASSISTANT T_?_USER_INFO LCO_ALLOT_TEACHER T_?_USER_INFO USER_DEPARTMENT DEPARTMENT COURSE# 2 0xB86C64C70BAA831C 10486.1545 29.0% 951 11.0265 0.55 SELECT STUDENT STUDENT_SCHOOL SCHOOL_TABLE STUDENT_ORGAN ORGAN ORDER_FORM T_?_USER_INFO STUDENT_SELL T_?_USER_INFO STUDENT_CONTACT_PERSON LEA_COU_ONE STUDENT_ASSISTANT T_?_USER_INFO LCO_ALLOT_TEACHER T_?_USER_INFO USER_DEPARTMENT DEPARTMENT COURSE# 3 0x3A8823AD8857EA9D 4635.8130 12.8% 3200 1.4487 1.33 SELECT STUDENT STUDENT_SCHOOL SCHOOL_TABLE STUDENT_ORGAN ORGAN ORDER_FORM T_?_USER_INFO STUDENT_SELL T_?_USER_INFO STUDENT_CONTACT_PERSON LEA_COU_ONE STUDENT_ASSISTANT T_?_USER_INFO LCO_ALLOT_TEACHER T_?_USER_INFO USER_DEPARTMENT DEPARTMENT COURSE# 4 0x86AC36DBACB13484 4626.3197 12.8% 3200 1.4457 2.07 SELECT STUDENT STUDENT_SCHOOL SCHOOL_TABLE STUDENT_ORGAN ORGAN ORDER_FORM T_?_USER_INFO STUDENT_SELL T_?_USER_INFO STUDENT_CONTACT_PERSON LEA_COU_ONE STUDENT_ASSISTANT T_?_USER_INFO LCO_ALLOT_TEACHER T_?_USER_INFO USER_DEPARTMENT DEPARTMENT COURSE# 5 0x0363FA1F2388C4D2 1527.4343 4.2% 2268 0.6735 0.29 SELECT STUDENT STUDENT_SCHOOL SCHOOL_TABLE STUDENT_ORGAN ORGAN ORDER_FORM T_?_USER_INFO STUDENT_SELL T_?_USER_INFO STUDENT_CONTACT_PERSON LEA_COU_ONE STUDENT_ASSISTANT T_?_USER_INFO LCO_ALLOT_TEACHER T_?_USER_INFO USER_DEPARTMENT DEPARTMENT COURSE# MISC 0xMISC 463.5191 1.3% 16357 0.0283 0.0 &lt;20 ITEMS&gt; 这部分对查询进行参数化并分组，然后对各类查询的执行情况进行分析，结果按总执行时长，从大到小排序。Response: 总的响应时间。time: 该查询在本次分析中总的时间占比。calls: 执行次数，即本次分析总共有多少条这种类型的查询语句。R/Call: 平均每次执行的响应时间。Item : 查询对象 第三部分# Query 1: 1.04 QPS, 4.65x concurrency, ID 0x3C82B414C14E5C06 at byte 45899007# Scores: V/M = 9.20# Time range: 2016-05-10 10:59:36 to 11:51:19# Attribute pct total min max avg 95% stddev median# ============ === ======= ======= ======= ======= ======= ======= =======# Count 11 3220# Exec time 39 14440s 89ms 27s 4s 17s 6s 816ms# Lock time 15 2s 370us 165ms 688us 881us 3ms 467us# Rows sent 3 3.14k 1 1 1 1 0 1# Rows examine 36 1.91G 244.46k 1.48M 620.56k 1.46M 573.76k 233.54k# Query size 17 8.38M 2.67k 2.67k 2.67k 2.67k 0 2.67k# String:# Hosts# Users admin# Query_time distribution# 1us# 10us# 100us# 1ms# 10ms ### 1s ############## 10s+ ############################## Tables# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'STUDENT'\\G# SHOW CREATE TABLE `mysqlnew`.`STUDENT`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'STUDENT_SCHOOL'\\G# SHOW CREATE TABLE `mysqlnew`.`STUDENT_SCHOOL`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'SCHOOL_TABLE'\\G# SHOW CREATE TABLE `mysqlnew`.`SCHOOL_TABLE`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'STUDENT_ORGAN'\\G# SHOW CREATE TABLE `mysqlnew`.`STUDENT_ORGAN`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'ORGAN'\\G# SHOW CREATE TABLE `mysqlnew`.`ORGAN`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'ORDER_FORM'\\G# SHOW CREATE TABLE `mysqlnew`.`ORDER_FORM`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'T_0_USER_INFO'\\G# SHOW CREATE TABLE `mysqlnew`.`T_0_USER_INFO`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'STUDENT_SELL'\\G# SHOW CREATE TABLE `mysqlnew`.`STUDENT_SELL`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'STUDENT_CONTACT_PERSON'\\G# SHOW CREATE TABLE `mysqlnew`.`STUDENT_CONTACT_PERSON`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'LEA_COU_ONE'\\G# SHOW CREATE TABLE `mysqlnew`.`LEA_COU_ONE`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'STUDENT_ASSISTANT'\\G# SHOW CREATE TABLE `mysqlnew`.`STUDENT_ASSISTANT`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'LCO_ALLOT_TEACHER'\\G# SHOW CREATE TABLE `mysqlnew`.`LCO_ALLOT_TEACHER`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'USER_DEPARTMENT'\\G# SHOW CREATE TABLE `mysqlnew`.`USER_DEPARTMENT`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'DEPARTMENT'\\G# SHOW CREATE TABLE `mysqlnew`.`DEPARTMENT`\\G# SHOW TABLE STATUS FROM `mysqlnew` LIKE 'COURSE'\\G# SHOW CREATE TABLE `mysqlnew`.`COURSE`\\G# EXPLAIN /*!50100 PARTITIONS*/select count(1)from(SELECT ATM_0.STUDENT_ID T_448_0,ATM_0.STU_NAME AFM_1,ATM_0.STU_SEX AFM_2,ATM_0.STU_SEX DIC_AFM_2,ATM_0.STU_PHONE AFM_3,ATM_0.STU_TYPE AFM_4,ATM_0.STU_TYPE DIC_AFM_4,ATM_0.EDUCATION AFM_5,ATM_0.EDUCATION DIC_AFM_5,ATM_0.ISVIP AFM_10,ATM_0.ISVIP DIC_AFM_10,ATM_0.STU_ABROADTIME AFM_12,ATM_0.STU_ABROADTIME DIC_AFM_12,ATM_0.F_33345 AFM_13,ATM_0.SK_STYLE AFM_14,ATM_0.SK_STYLE DIC_AFM_14,ATM_0.CREATE_DATE AFM_16,ATM_0.IF_XY AFM_25,ATM_0.IF_XY DIC_AFM_25,ATM_0.STUDENT_ID LMF_ID,ATM_24_0.STU_ID RP_STU_ID_0,ATM_23_0.STU_ID RP_STU_ID_1,ATM_17_0.STU_ID RP_STU_ID_2,ATM_11_0.STU_ID RP_STU_ID_4,ATM_8_0.STU_ID RP_STU_ID_5,ATM_6_0.STU_ID RP_STU_ID_6 FROM STUDENT ATM_0 INNER JOIN(SELECT ATM_24_0.STU_ID FROM STUDENT_SCHOOL ATM_24_0 LEFT JOIN SCHOOL_TABLE ATM_24_1 ON ATM_24_1.SCHOOL_TABLE_ID=ATM_24_0.SCH_ID WHERE 1=1 AND(ATM_24_1.SCHOOL_TABLE_ID IN(1)) 这部分是每种查询的详细情况最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。Databases: 库名Users: 各个用户执行的次数（占比）Query_time distribution : 查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。Tables: 查询中涉及到的表Explain: 示例 官方文档：http://www.percona.com/doc/percona-toolkit/2.2/pt-query-digest.html 参考：http://blog.csdn.net/seteor/article/details/24017913","link":"/APP/MySQL/Percona_Tookit_pt-query-digest.html"},{"title":"Swift：Array","text":"Swift官方API文档 对任何一门现代化编程语言来说，集合类型都是非常重要的组成部分。这一类数据类型的设计，很大程度上决定了开发者对某种编程语言的使用体验以及代码执行效率。因此，Swift在集合类型的设计和实现上，进行了诸多的考量，让它兼具易用性、高性能以及扩展性。 但是这样做也是有代价的，在Swift里，集合是个复杂的类型家族，它是由多个protocol形成的，因此当我们想深入其中一探究竟的时候，并不那么容易。 最简单也最常用的一个集合类型：Array。 创建一个ArrayArray表示一组有序（ordered）的数据集合，所谓有序，并不是指大小排序，而是指Array中的元素有先后的位置关系，稍后我们会看到，这个位置关系可以用来访问Array中的元素。在此之前，先来看了解如何定义Array对象。首先，我们可以通过下面三种方法定义一个空的Array： var array1: Array&lt;Int&gt; = Array&lt;Int&gt;()var array2: [Int] = []var array3 = array2 在上面的代码中，前两种使用了type annotation，Array和[Int]没有区别，你可以根据自己的喜好来选择。而第三种，我们直接使用了一个空的Array生成了一个新的Array对象。 其次，再来看一些定义数组时同时指定初始值的方法： // [3, 3, 3]var threeInts = [Int](repeating: 3, count: 3)// [3, 3, 3, 3, 3, 3]var sixInts = threeInts + threeInts// [1, 2, 3, 4, 5]var fiveInts = [1, 2, 3, 4, 5] 它们用起来都很直观，在稍后我们提到Sequence时，还会看到更复杂的Array初始化方法。 两个常用的Array属性（isEmpty，count）定义好数组之后，我们介绍两个Array最常用的属性。第一个是count，类型是Int。我们之前已经用过，用于获取数组中元素的个数： array1.count // 0fiveInts.count // 5 第二个是isEmtpy，类型是Bool。表示数组是否为空： if array2.isEmpty { // array2 is empty print(\"array2 is empty\")} 访问Array中的元素接下来，我们看访问Array元素的方法，它们之中有我们在其他语言中熟悉的，也有Swift独特的方式。首先，就是几乎所有语言都有的惯用法，使用索引。但是，它却也是在Swift，最不被推荐的使用方法： fiveInts[2] // 3fiveInts[5] // This will crash 就像，上面例子中这样。当使用索引访问数组元素时，你必须自行确保索引的安全性。如果索引超过了数组的范围，程序就会直接崩溃。其实，在Swift里，我们几乎不需要直接使用索引来访问数组元素。稍后，我们会专门提到Array的惯用法。因此，Swift开发者也没有对索引访问添加任何安全保护。言外之意就是，非要用，你自己对结果全权负责喽。 其次，是使用range operator访问数组的一个范围： fiveInts[0...2] // [1, 2, 3]fiveInts[0..&lt;2] // [1, 2] 要说明的是，使用range operator得到的，并不是一个Array，而是一个ArraySlice。什么是ArraySlice呢？简单来说，就是Array某一段内容的view，它不真正保存数组的内容，只保存这个view引用的数组的范围： // +---------+---+// | length | 5 |// +---------+---+// | storage ptr |// +---------+---+// |// v// +---+---+---+---+---+---------------------+// | 1 | 2 | 3 | 4 | 5 | reserved capacity |// +---+---+---+---+---+---------------------+// ^// |// +---------+---+// | storage ptr |// +---------+---+// | beg idx | 0 |// +---------+---+// | end idx | 3 | ArraySlice for [0...2]// +---------+---+ 从上面这个注释，就很容易理解view的概念了，它只记录了要表达内容的区间。但是我们也可以直接通过这个view创建新的Array对象： Array(fiveInts[0...2]) // [1, 2, 3] 这样，就得到了一个值是[1, 2, 3]的Array对象。 遍历数组除了访问单个元素外，另一类常用的需求就是顺序访问数组中的每个成员。在Swift里，我们有三种基本的方法遍历一个Array。 For（不推荐）for value in fiveInts { print(value)}// 1 // 2// .../* or */a.forEach { print($0) }// 1 // 2// ... enumerated()（不推荐）在遍历的时候，同时获得数组的索引和值，可以使用数组对象的enumerated()方法，它会返回一个Sequence对象，包含了每个成员的索引和值，我们同样可以在for循环中，依次访问它们： for (index, value) in fiveInts.enumerated() { print(\"\\(index): \\(value)\")}// 0: 1// 1: 2// ... 当我们要查找数组中元素的位置时（例如，查找等于1的元素的索引）： a.index { $0 == 1 } index会返回一个Optional，当要查找的元素存在时，就返回该元素的索引，否则，就返回nil。 当我们要筛选出数组中的某些元素时（例如，得到所有偶数）： a.filter { $0 % 2 == 0 } forEach借助closure，可以使用Array对象的forEach方法要注意它和map的一个重要区别：forEach并不处理closure参数的返回值。因此它只适合用来对数组中的元素进行一些操作，而不能用来产生返回结果。 fiveInts.forEach { print($0) } mapmap把for循环执行的逻辑，封装在了函数里，这样我们就可以把函数的返回值赋值给常量了 var fibonacci = [0, 1, 1, 2, 3, 5]var squares = [Int]()for value in fibonacci { squares.append(value * value)}//等同于下面方法let constSquares = fibonacci.map { $0 * $0 } 例如我们可以实现自己的map方法 extension Array { func myMap&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; [T] { var tmp: [T] = [] tmp.reserveCapacity(count) for value in self { tmp.append(transform(value)) } return tmp }}let constSequence1 = fibonacci.myMap { $0 * $0 } 仔细观察myMap的实现，就会发现它最大的意义，就是保留了遍历Array的过程，而把要执行的动作留给了myMap的调用者通过参数去定制 print(fibonacci.map { $0 }) // [0, 1, 1, 2, 3, 5]print(fibonacci.map { $0 * $0 }) //[0, 1, 1, 4, 9, 25] Array 其他的方法flatMap简单来说，如果你用在map中的closure参数不返回一个数组元素，而是也返回一个数组，这样，你就会得到一个数组的数组，但如果你只需要一个一维数组，flatMap就可以派上用场了 var animal = [\"cat\",\"dog\"]var ids = [\"1\",\"2\"]animal.flatMap { animal in return ids.map { id in (animal, id) } // [(.0 \"cat\", .1 \"1\"), (.0 \"cat\", .1 \"2\"), (.0 \"dog\", .1 \"1\"), (.0 \"dog\", .1 \"2\")]} 实际上，flatMap的实现很简单，只要在map内部的for循环里，不断把closure参数生成的数组的内容，添加到要返回的结果里就好了： extension Array { func myFlatMap&lt;T&gt;(_ transform: (Element) -&gt; [T]) -&gt; [T] { var tmp: [T] = [] for value in self { tmp.append(contentsOf: transform(value)) } return tmp }} 得到的结果，应该和之前使用flatMap是一样的： min() max()（返回最大最小值）var fibonacci = [0, 1, 1, 2, 3, 5]fibonacci.min() // 0fibonacci.max() // 5 filter（返回判断正确的值）var fibonacci = [0, 1, 1, 2, 3, 5]fibonacci.filter { $0 % 2 == 0 } //[0, 2]fibonacci.map { $0 % 2 == 0 } //[true, false, false, true, false, false] 我们可以自己来实现一个filter： extension Array { func myFilter(_ predicate: (Element) -&gt; Bool) -&gt; [Element] { //一个参数predicate用来设置筛选的条件，这个条件接受一个Element类型的参数，返回一个Bool值，最后让myFilter返回一个Element值 var tmp: [Element] = [] //定义一个空的数组用来存放筛选后的结果 for value in self where predicate(value) { //使用for循环，便利数组中的每一个元素 tmp.append(value) //把符合条件的值添加到tmp里面 } return tmp } func reject(_ predicate: (Element) -&gt; Bool) -&gt; [Element] { return filter { !predicate($0) } //指定的条件取反 } func allMatch(_ predicate: (Element) -&gt; Bool) -&gt; Bool { return !contains { !predicate($0) } }} myFilter：最核心的环节就是通过带有where条件的for循环找到原数组中符合条件的元素，然后把它们一一添加到tmp中，并最终返回给函数的调用者。然后，我们测试下myFilter reject：剔除掉数组中满足条件的元素 allMatch：基于这个contains，我们还可以给Array添加一个新的方法，用来判断Array中所有的元素是否满足特定的条件： var fibonacci = [0, 1, 1, 2, 3, 5]fibonacci.myFilter { $0 % 2 == 0 } //[0, 2]fibonacci.reject { $0 % 2 == 0 } // [1, 1, 3, 5]//我们只要把调用转发给filter，然后把指定的条件取反就好了。这样，剔除元素的代码语义上就会更好看一些：let evens = [2, 4, 6, 8]evens.allMatch { $0 % 2 == 0 } // true//在allMatch的实现里，只要没有不满足条件的元素，也就是所有元素都满足条件了 contains（是否存在满足条件的元素）fibonacci.contains { $0 % 2 == 0 } // true contains的一个好处就是只要遇到满足条件的元素，函数的执行就终止了 elementsEqual() starts()（比较数组）比较数组相等或以特定元素开始。对这类操作，我们需要提供两个内容 elementsEqual：比较数组元素是否完全相等 starts：比较数组的规则是否以特定序列开头 var fibonacci = [0, 1, 1, 2, 3, 5]fibonacci.elementsEqual([0, 1, 1], by: { $0 == $1 }) //falsefibonacci.starts(with: [0, 1, 1], by: { $0 == $1 }) //true sorted()（对数组进行排序）// [0, 1, 1, 2, 3, 5]fibonacci.sorted()// [5, 3, 2, 1, 1, 0]fibonacci.sorted(by: &gt;)let pivot = fibonacci.partition(by: { $0 &lt; 1 })fibonacci[0 ..&lt; pivot] // [5, 1，1，2, 3]fibonacci[pivot ..&lt; fibonacci.endIndex] // [0] 其中，sorted(by:)的用法是很直接的，它默认采用升序排列。同时，也允许我们通过by自定义排序规则。在这里&gt;是{ $0 &gt; $1 }的简写形式。Swift中有很多在不影响语义的情况下的简写形式。 而partition(by:)则会先对传递给它的数组进行重排，然后根据指定的条件在重排的结果中返回一个分界点位置。这个分界点分开的两部分中，前半部分的元素都不满足指定条件；后半部分都满足指定条件。而后，我们就可以使用range operator来访问这两个区间形成的Array对象。大家可以根据例子中注释的结果，来理解partition的用法。 reduce()（对数组所有内容合并）是把数组的所有内容，“合并”成某种形式的值，对这类操作，我们需要指定的，是合并前的初始值，以及“合并”的规则。例如，我们计算fibonacci中所有元素的和： fibonacci.reduce(0, +) // 12 在这里，初始值是0，和第二个参数+，则是{ $0 + $1 }的缩写。 了解reduce的进一步用法之前，我们先来自己实现一个： extension Array { func myReduce&lt;T&gt;(_ initial: T, _ next: (T, Element) -&gt; T) -&gt; T { //由于要把Array转化成某种形式的单一值，把它定义范型方法，按照用法应该有两个参数，第一个参数initial是Reduce的初始值，定义为T；第二个表示每次执行的方法，是一个clouser，有两个参数T, Element，并且返回合并后的结果T，最终myReduce返回T集合 var tmp = initial for value in self { tmp = next(tmp, value) } return tmp }}fibonacci.myReduce(0, +) // 12 它们的结果和标准库中的map和filter是一样的。但是，这种看似优雅的写法却没有想象中的那么好。在它们内部的reduce调用中，每一次$0的参数都是一个新建的数组，因此整个算法的复杂度是O(n2)，而不再是for循环版本的O(n)。所以，这样的实现方法最好还是用来作为理解reduce用法的例子。 append（在末尾添加）编辑Array中的元素。要在数组的末尾添加元素，我们可以这样： array1.append(1) // [1]array1 += [2, 3, 4] // [1, 2, 3, 4] insert（在中间位置添加）它的第一个参数表示要插入的值，第二个参数表示要插入的位置，这个位置必须是一个合法的范围，即0…array1.endIndex，如果超出这个范围，会直接引发运行时错误。 // [1, 2, 3, 4, 5]array1.insert(5, at: array1.endIndex) endIndex 末尾 startIndex 起始位置 array1[N] 指定位置 remove(at:)（删除元素的位置）要删除Array中的元素，可以使用remove(at:)方法，它只接受一个参数，表示要删除元素的位置，同样，你必须自行保证使用的at参数不超过数组的合法范围，否则会引发运行时错误。当然，如果你仅仅想删除数组中的最后一个元素，还可以使用removeLast()方法： array1.remove(at: 4) // [1, 2, 3, 4] 其他方法 array1.removeLast() // [1, 2, 3] removeAll 删除全部元素 //[] removeFirst 删除第一个元素 [2,3,4] removeLast 删除最后一个元素 [1,2,3] popLast 删除的最后一个元素（原Array已被删除） [4] NSArray在Foundation中，数组这个类型有两点和Swift Array是不同的： 数组是否可以被修改是通过NSArray和NSMutableArray这两个类型来决定的； NSArray和NSMutableArray都是类对象，复制它们执行的是引用语义； 当把这两个因素放在一起的时候，Foundation中的“常量数组”这个概念就会在一些场景里表现的很奇怪。因为你还可以通过对一个常量数组的非常量引用去修改它，来看下面的例子： // Mutable array [1, 2, 3]let b = NSMutableArray(array: [1, 2, 3])// Const array [1, 2, 3]let copyB: NSArray = b// [0, 1, 2, 3]b.insert(0, at: 0)// [0, 1, 2, 3]copyB 从上面的代码可以看到，尽管我们在创建copyB时，使用了NSArray，表明我们不希望它的值被修改，由于这个赋值执行的是引用拷贝，因此，实际上它和b指向的是同一块内存空间。因此，当我们修改b的内容时，copyB也就间接受到了影响。 为了在拷贝NSArray对象时，执行值语义，我们必须使用它的copy方法复制所有的元素： let b = NSMutableArray(array: [1, 2, 3])let copyB: NSArray = blet deepCopyB = b.copy() as! NSArrayb.insert(0, at: 0) // [0, 1, 2, 3]copyB // [0, 1, 2, 3]deepCopyB // [1, 2, 3] 从注释中的结果，你就能很容易理解deep copy的含义了。 当我们使用NSArray和NSMutableArray时，Swift中的var和let关键字就和数组是否可以被修改没关系了。它们只控制对应的变量是否可以被赋值成新的NSArray或NSMutableArray对象。","link":"/Swift/swift_array_study.html"},{"title":"Swift   Dictionary数据结构","text":"Dictionary是除了Array之外的另一种非常重要的数据结构，它用于把某种形式的key，关联到某种形式的value。我们来看一个例子。 定义Dictionary假设我们要定义一个数据结构，用来保存用户在泊学对某个视频的观看情况。可以这样： 假设我们要定义一个数据结构，用来保存用户在泊学对某个视频的观看情况。可以这样：enum RecordType { case bool(Bool) case number(Int) case text(String)}let record11: [String: RecordType] = [ \"uid\": .number(11), \"exp\": .number(100), \"favourite\": .bool(true), \"title\": .text(\"Dictionary basics\")] 在上面代码里，我们用[KeyType: ValueType]的形式来定义一个Dictionary。当定义好Dictionary之后，我们就能直接用[Key]来访问某个key对应的值了： record11[\"uid\"] // number(11)record11[\"favourite\"] // bool(true)record11[\"title\"] // text(\"Dictionary basics\")record11[\"invalid\"] // nil// Optional&lt;RecordType&gt;.Typetype(of: record11[\"favourite\"]) 上面例子中的结果都很直观。但是有一个细节却是值得我们注意的。和Array不同的是，[]用在Dictionary的时候，会返回一个Optional类型来确保这种形式的访问安全。因此，访问不存在的key，并不会导致运行时错误。 这是因为索引这个概念，对Array和Dictionary来说，是截然不同的。对于Array来说，我们有可能使用的正常索引值只源于Array自身，也就是0..&lt;array.count，因此，如果你使用了不在这个范围里的值，则一定是可以被定性为Bug的，何况，我们之前也看到了，对于Array，我们几乎不需要直接使用索引来访问元素。 而对于Dictionary来说，它包含的内容并不直接决定我们可以查询的内容。举个例子来说，英汉词典中也可能并不包含我们要查询的单词。所以，Dictionary中包含的所有键值，从语义上说，并不完全决定了它的使用者会查询的值，所以，我们也无法把这类问题明确的归因于是Bug。所以，Swfit为Dictionary的索引查询操作，提供了optional保护。要么得到正确的结果，要么通过nil表示要查询的内容不存在。 常用的基本属性作为一个集合类型，Dictionary同样有count和isEmpty两个属性读取其元素的个数以及判断其是否为空： record11.count // 4record11.isEmpty // false 另外，我们可以单独访问一个Dictionary的所有keys和所有values： record11.keysrecord11.values 这两个属性也分别是一个集合，我们可以暂时忽略掉它们具体的类型，如果要我们要访问它们的每一个元素，直接用for循环或forEach遍历就好了： for key in record11.keys { print(key) }// orrecord11.keys.forEach { print($0) } 添加、更新和删除元素和Array一样，Dictionary也是一个值类型，当我们复制Dictionary对象的时候，就会拷贝Dictionary中的所有内容： var record10 = record11 并且，直接使用key就可以访问和修改Dictionary的内容： record10[\"favourite\"] = .bool(false) // falserecord11[\"favourite\"] // true 如果我们希望更新value的时候，同时获得修改前的值，还可以使用updateValue(_:forKey:)方法： record10.updateValue(.bool(true), forKey: \"favourite\") // .bool(false) 从上面的结果可以看出修改record10并不会影响record11。 当我们要在Dictionary中添加元素时，直接给要添加的key赋值就好了： record10[\"watchLater\"] = .bool(false)// [// \"favourite\": RecordType.bool(false),// \"exp\": RecordType.number(100),// \"title\": RecordType.text(\"Directory basics\"),// \"uid\": RecordType.number(11),// \"watchLater\": RecordType.bool(false)// ] 这样，record10中的内容，就变成了5项。而当我们要删除特定的key时，直接把它的值设置为nil： record10[\"watchLater\"] = nil// [// \"favourite\": RecordType.bool(false),// \"exp\": RecordType.number(100),// \"title\": RecordType.text(\"Directory basics\"),// \"uid\": RecordType.number(11)// ] 这里，并不是把特定key的值设置为nil（毕竟Dictionary中value部分的类型也不是optional），而是删除特定的key。当某个key的value被设置成nil后，这个key也就从Dictionary中删除了。 遍历Dictionary由于Dictionary同时包含了key和value，因此，我们也有多重方式来遍历Dictionary。最简单的，就是遍历Dictionary中的每一个元素： for (k, v) in record10 { print(\"\\(k): \\(v)\")}//orrecord10.forEach { print(\"\\($0): \\($1)\") } 从上面的例子可以看到，遍历Dictionary和遍历Array是类似的。当我们使用for循环遍历时，它的每一个元素都用一个tuple来表示，封装了每一个元素的key和value。而当使用forEach方法时，它会给它的closure参数传递两个值，分别是每一个元素的key和value。[^^]: # (但是，由于Dictionary是一个无序集合（unordered collection），因此当我们编辑了Dictionary之后，每次遍历，访问元素的顺序都可能是不同的。如果我们希望按照固定的顺序来访问Dictionary中的元素，一个最简单的办法，就是对key排序后，再进行遍历：)[^^]: # (for key in record10.keys.sorted() {print(“(key): (record10[key])”)}) 合并进不同的设置enum RecordType { case bool(Bool) case number(Int) case text(String)}let defaultRecord: [String: RecordType] = [ \"uid\": .number(0), \"exp\": .number(100), \"favourite\": .bool(false), \"title\": .text(\"\")] 这样，当创建新纪录时，我们希望保持默认记录中的默认值，同时合并进不同用户的设置，例如： var template = defaultRecordvar record11Patch: [String: RecordType] = [ \"uid\": .number(11), \"title\": .text(\"Common dictionary extensions\")]// How can we do this?// template.merge(record11Patch)// [// uid: .number(11),// \"exp\": .number(100),// \"favourite\": .bool(false),// \"title\": .text(\"Common dictionary extensions\")// ] merge然而，该如何实现这个merge呢？最重要的事情，就是要想一下什么内容可以被merge进来。最一般的情况来说，无论任何形式的序列，只要它的元素中key和value的类型和Dictionary相同，就可以进行合并。 如何在代码中表达这个特征呢？来看下面的例子： extension Dictionary { mutating func merge&lt;S:Sequence&gt;(_ sequence: S) where S.Iterator.Element == (key: Key, value: Value) { sequence.forEach { self[$0] = $1 } }} 由于Dictionary是一个struct，并且merge修改了self，我们必须使用mutating关键字修饰这个方法。而对于sequence参数，我们通过where关键字限定了两个内容： S必须遵从Sequence protocol，Dictionary是众多遵从了Sequence protocol的collection类型之一，但是，我们没必要一定只能合并Dictionary； S的元素类型必须和原Dictionary的Element相同，其中Key和Value是Dictionary声明中的两个泛型参数；解决了参数问题之后，实现合并的算法就很简单了，我们只是更新self中每一个和sequence有相同key的值就好了。 这样，之前template.merge(record11Patch)就可以正常工作了。 既然，我们把merge参数的约束定义为了Sequence，那我们就来看一个合并非Dictionary类型的情况，例如，合并一个包含正确内容的Array： let record10Patch: [(key: String, value: RecordType)] = [ (key: \"uid\", value: .number(10)), (key: \"title\", value: .text(\"Common dictionary extensions\"))]var template1 = defaultRecordtemplate1.merge(record10Patch)// [// uid: .number(10),// \"exp\": .number(100),// \"favourite\": .bool(false),// \"title\": .text(\"Common dictionary extensions\")// ] 在上面的代码里，我们合并了一个tuple数组，它的类型是Array&lt;String, RecordType&gt;，数组中的每一项都包含了一个要合并进来的键值对。如果没有意外，合并Array和Dictionary都应该是可以正常工作的。 按照我们对merge的实现方式，实际上，任何一个遵从了Sequence protocol的类型，只要它包含了和template相同的元素类型，都是可以merge的。 用一个tuple数组初始化Dictionary理解了merge的实现和用法之后，其实，我们很容易把这个场景进一步扩展下，如果我们可以merge类型兼容的Sequence，那么，用这样的Sequence来初始化一个Dictionary也是可以的，把它看成是和一个空的Dictionary进行合并就好了： extension Dictionary { init&lt;S:Sequence&gt;(_ sequence: S) where S.Iterator.Element == (key: Key, value: Value) { self = [:] self.merge(sequence) }} 有了这个方法之后，我们直接用下面的代码就可以创建一个新的Dictionary对象： let record11 = Dictionary(record11Patch)// [// uid: .number(11),// \"title\": .text(\"Common dictionary extensions\")// ] 定制map的行为最后一个要介绍的常用功能，是定制Dictionary.map的行为，默认情况下它返回的是一个Array，例如： record11.map { $1 }// [ .number(11).text(\"Common dictionary extensions\")] 在上面的例子里，map返回一个Array，但有时，我们仅仅希望对value做一些变换，而仍旧保持Dictionary的类型。为此，我们可以自定义一个“只map value”的方法： 们可以自定义一个“只map value”的方法：extension Dictionary { func mapValue&lt;T&gt;(_ transform: (Value) -&gt; T) -&gt; [Key: T] { return Dictionary&lt;Key, T&gt;(map { (k, v) in return (k, transform(v)) }) }} 在这个实现的最内部，我们用标准库中的map得到了一个Array&lt;(String, RecordType)&gt;类型的Array，而后，由于Array也遵从了Sequence protocol，因此，我们就能直接使用这个Array来定义新的Dictionary了。 完成之后，用下面的代码测试下： let newRecord11 = record11.mapValue { record -&gt; String in switch record { case .text(let title): return title case .number(let exp): return String(exp) case .bool(let favourite): return String(favourite) }}// [// \"uid\": \"11\",// \"title\": \"Common dictionary extensions\"// ]这样，我们就用record11生成了一个Dictionary&lt;String, String&gt;类型的对象。","link":"/Swift/swift_dicrionary.html"},{"title":"Swift中String","text":"忘了String是字符数组在Swift里，String已经彻底不再是一个集合类型。而是一个提供了从多个维度展现一个Unicode视图的类型。你可以得到它的多个Characters，可以看到它的UTF-8 / UTF-16 / Unicode scalar值等等。 String和NSString处理Unicode时的差异unicode长度是可变的，我们将看到unicode另外一个可变的特性，即组成同一个字符的code unit组合也是可变的。而区分String和NSString的一个重要方式，就是它们对unicode的这个特性的处理方式，是不同的。为了理解这个事情，我们从unicode grapheme clusters说起。 Unicode grapheme clusters首先，我们定义一个字符串： let cafe = \"Caf\\u{00e9}\" 返回 Café Swift里，我们可以使用\\u{}这样的方式使用unicode scalar定义unicode字符。 对于单词Café中的最后一个字符来说，它的unicode scalar是U+00E9，名字是LATIN SMALL LETTER E WITH ACUTE。每一个unicode都有一个scalar值以及一个全大写字母表示的名称。 为了表示这个字符é，除了使用它的unicode scalar外，我们可以用两个其它的unicode字符拼起来： 英文字母e，它的unicode scalar是U0065，name是LATIN SMALL LETTER E； 声调字符’，它的unicode scalar是U0301，name是COMBINING ACUTE ACCENT； 当我们把这两个字符像下面这样组合起来的时候： let cafee = \"Caf\\u{0065}\\u{0301}\" 返回 Café 尽管cafee的定义中貌似有5个字符，但实际显示出来的最后一个字符和之前用unicode scalar定义是一样的。我们管\\u{0065}\\u{0301}就叫做grapheme cluster。 既然同一个unicode字符可以有多种表现形式，那么由不同code unit构成的字符串相等么？对此，Swift中的String和Objective-C中的NSString处理方式却是有差别的，这种差别，是区分它们最明显的地方之一。 Canonically equivalent为了能识别上面cafe和cafee的情况，unicode规范中提出了一个概念：canonically equivalent。如何理解它呢？我们先来看Swift是如何识别cafe和cafee的。 Swift String当我们要读取一个字符串中所有的字符时，可以访问String对象的characters属性，在下个视频中，我们会更多讲到它的用法： let cafe = \"Caf\\u{00e9}\"let cafee = \"Caf\\u{0065}\\u{0301}\"cafe.characters.countcafee.characters.count 返回 44 尽管cafee中最后一个字符的定义使用了两个code unit，Swift可以识别的Character中字符的个数也是4。 但是，当我们查看cafe和cafee的UTF-8和UTF-16编码的个数时，就能看到它们的区别了： cafe.utf8.countcafee.utf8.countcafe.utf16.countcafee.utf16.count 返回 56 45 为什么会这样呢？我们用UTF-8编码举例： 对于cafe来说，é的UTF-8编码是C3 A9，加上前面Caf的编码是43 61 66，因此cafe的UTF-8编码个数是5； 对于cafee来说，声调字符’的UTF-8编码是CC 81，加上前面Cafe的UTF-8编码是43 61 66 65，因此是6个，它相当于Cafe’； 理解了之后，你可以自己去推算一下UTF-16的情况。 尽管cafe和cafee的编码方式不同，当我们在Swift中，比较cafe和cafee时，结果会是true： cafe == cafee 返回 true 这就是unicode canonically equivalent的含义，通过这些例子，你也能更好的了解到Swift在unicode表意正确上作出的努力。 NSString而当我们把这些例子用在NSString上，情况就会有些不同。用同样的code unit定义下面两个NSString对象： let nsCafe = NSString(characters: [0x43, 0x61, 0x66, 0xe9], length: 4)nsCafe.lengthlet nsCafee = NSString(characters: [0x43, 0x61, 0x66, 0x65, 0x0301], length: 5)nsCafee.length 返回 Café4Café5 可以看到，同样是使用不同的code unit构建字符串”Café”，在NSString看来，它们是长度不同的两个字符串。 因此，当我们比较nsCafe和nsCafee的时候，结果也是没有意外的false： nsCafe == nsCafee 返回 false 因此，==对NSString来说，并没有执行canonically equivalent的语义。为了在不同的NSString对象之间进行语义比较，我们只能这样： let result = nsCafe.compare(nsCafee as String)result == ComparisonResult.orderedSame 返回 NSComparisonResulttrue 可以看到，这样就能按照canonically equivalent的方式判断相等了。","link":"/Swift/swift_string.html"},{"title":"Vapor系列教程 - MySQL数据库","text":"Vapor默认使用的SQLite数据库 创建新项目vapor new Test 修改相关文件项Package.swiftimport PackageDescriptionlet package = Package( name: \"HeyAT\", dependencies: [ .package(url: \"https://github.com/vapor/vapor.git\", from: \"3.0.0\"), .package(url: \"https://github.com/vapor/crypto.git\", from: \"3.3.0\"), .package(url: \"https://github.com/vapor/fluent-mysql.git\", from: \"3.0.0\") ], targets: [ .target(name: \"App\", dependencies: [\"FluentMySQL\", \"Crypto\", \"Vapor\"]), .target(name: \"Run\", dependencies: [\"App\"]), .testTarget(name: \"AppTests\", dependencies: [\"App\"]) ]) 修改configure.swiftimport FluentMySQLimport Vapor/// Called before your application initializes.public func configure(_ config: inout Config, _ env: inout Environment, _ services: inout Services) throws { // Register providers first try services.register(FluentMySQLProvider()) // Register routes to the router let router = EngineRouter.default() try routes(router) services.register(router, as: Router.self) // Register middleware var middlewares = MiddlewareConfig() // Create _empty_ middleware config // middlewares.use(FileMiddleware.self) // Serves files from `Public/` directory middlewares.use(ErrorMiddleware.self) // Catches errors and converts to HTTP response services.register(middlewares) // Configure a MySQL database var databases = DatabasesConfig() //定义mysql数据库配置参数的变量 let mysqlHost: String let mysqlPort: Int let mysqlDB: String let mysqlUser: String let mysqlPass: String if env == .development || env == .testing { //线下环境使用的配置信息 mysqlHost = \"127.0.0.1\" mysqlPort = 3306 mysqlDB = \"vapor\" mysqlUser = \"root\" mysqlPass = \"qiqi.loveAI001\" } else { //生产环境，读取机器配置的配置，如果读取失败，则取默认值 mysqlHost = Environment.get(\"MYSQL_HOST\") ?? \"127.0.0.1\" mysqlPort = 3306 mysqlDB = Environment.get(\"MYSQL_DB\") ?? \"vapor\" mysqlUser = Environment.get(\"MYSQL_USER\") ?? \"root\" mysqlPass = Environment.get(\"MYSQL_PASS\") ?? \"qiqi.loveAI001\" } let mysqlConfig = MySQLDatabaseConfig( hostname: mysqlHost, port: mysqlPort, username: mysqlUser, password: mysqlPass, database: mysqlDB, transport: .unverifiedTLS) let mysql = MySQLDatabase(config: mysqlConfig) databases.add(database: mysql, as: .mysql) services.register(databases) // Migration配置 Business.defaultDatabase = .mysql var migrations = MigrationConfig() migrations.add(model: Business.self, database: .mysql) migrations.add(model: Instance.self, database: .mysql) migrations.add(model: User.self, database: .mysql) migrations.add(model: AccessToken.self, database: .mysql) //开发环境填充测试数据 if env == .development { migrations.add(migration: BusinessSeeder.self, database: .mysql)// migrations.add(migration: InstanceSeeder.self, database: .mysql) } services.register(migrations) /** # 注册migrations命令 - vapor run migrate: 执行migrate创建表，并执行seed构建测试数据 - vapor run revert -all: 依照migrate创建表顺序，依次清空表数据后删除该表 */ var commandConfig = CommandConfig.default() commandConfig.useFluentCommands() services.register(commandConfig) } 修改 Todo.swiftimport FluentMySQLimport Vapor/// A single entry of a Todo list.final class Todo: MySQLModel { /// The unique identifier for this `Todo`. var id: Int? /// A title describing what this `Todo` entails. var title: String /// Creates a new `Todo`. init(id: Int? = nil, title: String) { self.id = id self.title = title }}/// Allows `Todo` to be used as a dynamic migration.extension Todo: Migration { }/// Allows `Todo` to be encoded to and decoded from HTTP messages.extension Todo: Content { }/// Allows `Todo` to be used as a dynamic parameter in route definitions.extension Todo: Parameter { }","link":"/Swift/Vapor/Vapor_MySQL_Use.html"},{"title":"Vapor 用于处理异步事件的非阻塞架构","text":"Vapor中使用Future和Promise几乎任何一个有可能带来请求延迟的操作，Vapor都会采用Future来处理，例如： 返回渲染过的页面，会用Future&lt;View&gt;； 返回HTTP状态码，会用Future&lt;HTTPStatus&gt;； 返回HTTP请求，会用Future&lt;Response&gt;； 在Vapor里，只要返回来自Model中的内容，它就一定是一个Future&lt;T&gt; 修改EpisodeVapor中的做法。为了表示某个在未来会返回的值，我们要使用Future&lt;T&gt;来表示。例如，在未来会得到一个Int就是Future&lt;Int&gt;，在未来会得到一个String，就是Future&lt;String&gt;，以此类推。 因此，对于上一节的/episodes/id这个API，如果Episode对象是通过数据库查询而来，我们最先要修改的，是遵从protocol Parameter时实现的resolveParameter，它返回的，应该是一个Future&lt;Episode?&gt;，而不是Episode。 static func resolveParameter(_ parameter: String, on container: Container) throws -&gt; Future&lt;Episode?&gt; {} 尽管之前Episode的init方法我们处理了字符串id无法转换成整数的情况，但为了更接近实际情况，这里，我们还是返回了Future&lt;Episode?&gt;而不是Future&lt;Episode&gt;，并且这样做也方便我们稍后演示更多Future的用法。 接下来，该怎么实现它呢？由于现在我们知识有限，因此，不会引入真正的异步操作，而只是创建一个Future对象来体会下它的用法： static func resolveParameter(_ parameter: String, on container: Container) throws -&gt; Future&lt;Episode?&gt; { return Future.map(on: container) { Episode(id: parameter) }} 这里Future.map就是完成映射的方法，它的第一个参数on表示执行任务的线程，我们暂时先不用太多关心它。而后面的closure则是生成Future要封装的值的过程。可以看到，我们还是硬编码了一个Episode对象。不过这次，概念上，我们就得到了一个“在未来的某个时候是Episode?”的值。 接下来，我们修改下Episode的定义： struct Episode: Content { var id: Int var desc: String init(id: Int, desc: String) { self.id = id self.desc = desc } init?(id: String) { if let eid = Int(id) { self.init(id: eid, desc: \"Description of episode \\(eid)\") } else { return nil } }} 这次，我们定义了memberwise initializer，并且让之前的init(id: String)变成了failable initializer。这样比之前用一个默认值的实现更接近实际的情况。 修改路由当我们再调用req.parameters.next(Episode.self)尝试把URL中的参数自动转换成Episode对象的时候，我们就会得到一个Future&lt;Episode?&gt;对象，而不再是之前的Episode对象。但给前端返回一个Optional并不是个好主意，我们应该把这个Future&lt;Episode?&gt;变成Future&lt;Episode&gt;。为此，我们可以使用另外一个版本的Future.map方法。 综合上面这些修改，我们把/episodes的路由改成这样： router.get(\"episodes\", Episode.parameter) { req -&gt; Future&lt;Episode&gt; in let episode = try req.parameters.next(Episode.self) return episode.map(to: Episode.self) { episode in guard let episode = episode else { throw Abort(.badRequest) } return episode }} 可以看到，这次，/episodes已经返回了Future&lt;Episode&gt;。在它的实现里，episode的类型是Future&lt;Episode?&gt;。然后，我们使用Future.map： 它的第一个参数to表示要映射的值的类型；第二个参数表示映射的过程。如果Future包装的Episode对象不为nil，我们就直接返回这个对象。否则就抛出一个Abort异常，这是Vapor提供的一个错误类型。实际上，它可以接受很多参数表示HTTP错误的相关信息，但只有一个参数是必选的。就是我们这里传递的.badRequest。这是一个enum HTTPResponseStatus中的一个case，表示HTTP 400错误。这样，路由这边的修改就完成了 当我们访问/episodes/5，就会得到对应记录的JSON： 用Future处理单一任务的常用方法map和flatMap正因为Future在Vapor中极为普遍，Vapor也提供了很多辅助函数来帮助我们使用Future。这一节，我们就来总结一下这些套路，适应并且掌握它们非常重要。因为在接下来的Vapor各种组件中，我们会频繁使用这些方法。首先，是最基础的两个方法map和flatMap，它们都返回一个Future对象，唯一的区别就是当它们的closure生成的值自身是一个Future的时候，用flatMap，否则用map。实际上，上一节最后，我们已经使用了map方法： episode.map(to: Episode.self) { episode in guard let episode = episode else { throw Abort(.badRequest) } return episode} 可以看到，在map的closure参数里，我们返回的是一个Episode对象，它不是一个Future对象。因此，这里直接用map就可以把closure的返回值封装成一个Future&lt;Episode&gt;了。 接下来，为了演示flatMap以及后续的例子，我们直接在routes.swift中添加两个辅助方法： func getEpisode(from req: Request) -&gt; Future&lt;Episode&gt; { return req.future( Episode(id: 1, desc: \"Just for demo.\") )}func save(_ episode: Episode, for req: Request) -&gt; Future&lt;Response&gt; { return episode.encode(status: .created, for: req)} 其中： getEpisode模拟根据用户请求生成Episode对象，通常这个过程要解码上传数据，因此我们返回了Future&lt;Episode&amp;gt。另外，这里为了避免引入更多的内容，我们还是使用了硬编码的方法； save模拟把生成的Episode对象返回给客户端；这里，我们使用了encode方法把episode的值编码成JSON（这是Episode遵从了protocol Content之后的免费福利），并通过status参数指定了返回的HTTP状态码。同样，在Vapor里，编码过程也会被认为是个可能带来延迟的操作，因此，encode返回的不是表示HTTP返回信息的Response，而是Future&lt;Response?&gt;； 有了这两个方法之后，我们添加一个POST /episode路由，模拟处理用户上传数据： router.post(\"episode\") { req in return getEpisode(from: req) .flatMap(to: Response.self) { episode in return save(episode, for: req) } } 在它的实现里可以看到，我们用getEpisode得到了用户上传的内容，并生成了Episode对象。此时，我们得到的，是一个Future&lt;Response&gt;。接下来，为了保存这个这个Episode对象，我们使用了flatMap方法，在它的closure中，我们调用了save。这就是我们在一开始说的，用于类型转换的closure自身也返回一个Future的情况。如果我们使用map就会得到Future&lt;Future&lt;Response&gt;&gt;，这显然不是我们想要的。得到的JSON和HTTP状态码，就是我们在save函数中返回的值。 transform但有时，我们并不关心一个Future中具体的值。例如刚才那个保存episode的操作，我们只是想告诉客户端：行，我知道了，你放心吧，我保证完成任务。然后就不再发送其它细节信息了。这种情况，我们就可以直接使用transform方法，直接把Future中的数据进行变换： router.post(\"episode\") { req in return getEpisode(from: req) .flatMap(to: Response.self) { episode in return save(episode, for: req) } .transform(to: HTTPStatus.noContent) } 这样，flatMap返回的Future就会被直接变成Future，重新请求下，得到的结果就会变成这样：没有了JSON，HTTP状态码也变成了204。 用Future处理多个任务的常用方法","link":"/Swift/vapor_io.html"},{"title":"Vapor 通过URL返回自定义类型","text":"自定义参数类型首先，在Sources/App/Models中，我们新建一个文件Episode.swift，在这里，定义一个类型Episode，表示数据库中的视频对象： struct Episode { var id: Int var desc: String init(id: String) { if let eid = Int(id) { self.id = eid self.desc = \"Description of episode \\(self.id)\" } else { self.id = 0 self.desc = \"Invalid episode\" } }} 定义路由/routers router.get(\"episodes\", Episode.parameter) { req -&gt; String in let episode = try req.parameters.next(Episode.self) return \"Episode id: \\(episode.id)\\nEpisode desc: \\(episode.desc)\"} 这次，为了可以通过try req.parameters.next(Episode.self)直接通过传入的ID得到对应的Episode对象。在Model中我们要让Episode遵从protocol Parameter： extension Episode: Parameter { static func resolveParameter(_ parameter: String, on container: Container) throws -&gt; Episode { return Episode(id: parameter) }} 其中： parameter表示要解析出Episode对象的参数，这里也就是我们通过URL传递的ID； container我们暂时还用不到，所以先忽略它就好了； 这样，我们就可以修改之前的/episodes路由了： 让路由返回JSON我们只要让Episode遵从protocol Content就好了： struct Episode: Content { var id: Int var desc: String init(id: String) { if let eid = Int(id) { self.id = eid self.desc = \"Description of episode \\(self.id)\" } else { self.id = 0 self.desc = \"Invalid episode\" } }} 剩下的事情，就都交给Vapor就好。这样，在/episode路由中，我们可以直接返回Episode对 router.get(\"episodes\", Episode.parameter) { req -&gt; Episode in return try req.parameters.next(Episode.self)}","link":"/Swift/vapor_url_response.html"},{"title":"vim 插件管理器 Vundle 安装与配置","text":"安装插件管理器 Vundlegit clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 配置修改~/.vimrc https://raw.githubusercontent.com/HeySoyl/MyVimrc/master/vimrc 命令安装插件 打开vim输入:PluginInstall :PluginInstall命令会安装在.vimrc文件中列出来的所有插件 :PluginInstall &lt;plugin-name&gt; 安装指定的插件 从命令行安装vim +PluginInstall +qall 清理未用插件 打开vim输入:PluginClean 从命令行安装vim +:PluginClean 搜索插件 打开vim输入:PluginSearch &lt;text-list&gt; 从命令行安装vim +:PluginSearch &lt;text-list&gt;","link":"/uncategorized/vim_vundle.html"},{"title":"同一台电脑添加多个ssh key","text":"生成密钥同样的方式可以生成多个 ssh-keygen -t rsa -C soyl@live.cn 执行命令ssh-keygen -t rsa -C email 创建github对应的sshkey，命名为id_rsa_github，密码123456 Generating public/private rsa key pair.Enter file in which to save the key (/Users/soyl/.ssh/id_rsa): id_rsa_githubEnter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in id_rsa_github.Your public key has been saved in id_rsa_github.pub.The key fingerprint is:SHA256:rZQO751cjfzzjDxJq5ZjI6pKKMWFlO6J+ZdvnWcra6M soyl@live.cnThe key's randomart image is:+---[RSA 2048]----+| .. || ... || .. . || ... o || +o. . S . ||o.o. = . . o. ||... .. .+. +o.o || ...o ..*o+o*o=o || ..+E++B==.+++o|+----[SHA256]-----+ Config配置在.ssh目录创建config文件(无后缀名，就是为了映射）并完成相关配置(最核心的地方) 每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可 Host 名字可以取为自己喜欢的名字，不过这个会影响git相关命令，例如： Host mygithub 这样定义的话，命令如下，即git@后面紧跟的名字改为mygithub git clone git@github.com:HeySoyl/HeyAT-API.git 就变成了 git clone git@mygithub:HeySoyl/HeyAT-API.git HostName 这个是真实的域名地址 IdentityFile 这里是id_rsa的地址 PreferredAuthentications配置登录时用什么权限认证–可设为publickey,password publickey,keyboard-interactive等 User 配置使用用户名 配置文件如下： # github.com的配置Host github.com HostName github.com IdentityFile ~/.ssh/id_rsa_github PreferredAuthentications publickey User HeySoyl# code.aliyun.com的配置Host code.aliyun.com HostName code.aliyun.com IdentityFile ~/.ssh/id_rsa_aliyun PreferredAuthentications publickey User Soyl 设置用户名设置全局用户名 git config --global --user.name \"yourname\"git config --global --user.email \"youremail\" 在仓库目录下设置局部用户名和邮箱 git config user.name \"yourname\" git config user.email \"youremail\"","link":"/Git/ssh_key.html"},{"title":"解决docker-compose 命令不存在、未找到命令错误","text":"安装安装扩展源sudo yum -y install epel-release 安装python-pip模块sudo yum install python-pip 查看docker-compose版本docker-compose version 提示未找到命令 通过以命令进行安装cd /usr/local/bin/wget https://github.com/docker/compose/releases/download/1.14.0-rc2/docker-compose-Linux-x86_64rename docker-compose-Linux-x86_64 docker-compose docker-compose-Linux-x86_64chmod +x /usr/local/bin/docker-compose 再次查看 docker-compose version 命令 compose以守护进程模式运行加-d选项 docker-compose up -d 查看有哪些服务 docker-compose ps 查看compose日志 docker-compose logs webdocker-compose logs redis 停止compose服务 docker-compose stopdocker-compose ps 重启compose服务 docker-compose restartdocker-compose ps kill compose服务 docker-compose psdocker-compose kill 删除compose服务 docker-compose rm","link":"/APP/Docker/docker-compose-no.html"},{"title":"用户协议","text":"重要提示：请您仔细阅读以下条款，并确认您已完全理解本协议之规定，尤其是免除及限制责任的条款、知识产权条款、法律适用及争议解决条款。若您对本声明或本协议任何条款有异议，请停止注册或使用Soyl（soyl.tech，包括手机、电脑等移动设备客户端，下同）所提供的全部服务。 一、协议的接受、变更与补充1、本协议是用户 (自然人、法人或社会团体)与Soyl Liu之间关于“轻启药箱”软件产品（以下简称“本软件产品”）的法律协议。一旦安装、复制或以其他方式使用本软件产品，即表示同意接受协议各项条件的约束。如果用户不同意协议的条件，请不要使用本软件产品。 2、Soyl Liu有权利对本协议进行修改，协议修改后，将通过在相关页面公告或发送通知等方式公布修改的内容，修改后的协议一经公布即有效的代替原协议。如果您不同意本协议的修改，请立即停止访问或使用本网站或取消已经获得的服务；如果您选择继续访问或使用本网站，则视为您已接受本协议的修改。 3、签署的本协议所列明的条款，并不能完全涵盖您与soyl.tech之间所有的权利和义务。因此，Soyl Liu不定期公布的其他声明、规则等均视为本协议之补充协议，为本协议不可分割的组成部分，与本协议具有同等法律效力。 4、如本协议与 soyl.tech 平台其它协议条款不一致，以其它协议条款内容为准。 二、用户个人信息1、个人信息的保护(1)保护用户个人信息及个人隐私是轻启药箱的基本原则之一。 (2)您在注册帐号或使用轻启药箱服务的过程中，需要填写一些必要的信息。若国家法律法规有特殊规定的，您可能还需要填写真实的身份信息。若您填写的信息不完整，可能无法注册帐户，或在使用轻启药箱服务过程中受到限制。 (3)我们将尽一切可能采取适当的技术手段，保证您可以访问、更新和更正自己的注册信息或使用我们的服务时提供的其他个人信息，但出于安全性和身份识别（如找回密码服务）的考虑，您可能无法修改注册时提供的初始注册信息及其他验证信息。 (4)轻启药箱将运用各种安全技术和程序建立完善的管理制度来保护您的个人信息，以免遭受未经授权的访问、使用或披露。 (5)未经您的同意，轻启药箱不会向轻启药箱以外的任何公司、组织和个人披露您的个人信息，但法律法规另有规定的除外。 (6)轻启药箱非常重视对未成年人个人信息的保护，若未成年人（尤其是十岁以下）希望得以使用轻启药箱提供的服务，必须得到父母（监护人）的同意。 (7)轻启药箱将通过技术手段、强化内部管理等办法充分保护用户的个人隐私信息，保证不对外公开或向第三方披露或提供用户注册资料及用户在使用网络服务时存储在soyl.tech平台、服务器或数据库的非公开内容和信息，但下列情况除外： 事先获得用户的授权； 根据有关的法律法规要求； 按照相关政府主管部门和司法机关的要求； 为维护社会公众的利益； 为维护轻启药箱的合法权益。 2、个人信息的收集轻启药箱在提供服务时，可能会收集、储存和使用下列与您有关的信息。如果您不提供相关信息，可能无法注册成为我们的用户或无法享受我们提供的某些服务，或者无法达到相关服务拟达到的效果。(1) 您提供的信息 您在注册帐户或使用轻启药箱的服务时，向我们提供的相关个人信息，包括但不限于真实姓名、证件信息、电话号码、地址、电子邮件等； 您通过轻启药箱的服务向其他方提供的共享信息，以及您使用我们的服务时所储存的信息。 (2)我们获取的您的信息您使用轻启药箱服务时我们可能收集如下信息：使用轻启药箱服务时，系统可能通过cookies、web beacon或其他方式自动采集的技术信息，包括： 设备或软件信息，包括但不限于您的移动设备、网页浏览器或用于接入我们服务的其他程序所提供的配置信息、您的IP地址、位置信息、设备存储和移动设备所用的版本和设备识别码； 在使用我们服务时搜索或浏览的信息，包括但不限于您浏览过的文章、搜索的关键词，以及您在使用我们服务时浏览或要求提供的其他信息和内容详情； 有关您曾使用的移动应用（APP）和其他软件的信息，以及您曾经使用该等移动应用和软件的信息。 3、个人信息的使用(1)我们可能将在向您提供服务的过程之中所收集的信息用作下列用途： 向您提供服务； 在我们提供服务时，用于身份验证、客户服务、安全防范、诈骗监测、存档和备份用途，确保我们向您提供的产品和服务的安全性； 帮助我们设计新服务，改善我们现有服务； 使我们更加了解您如何接入和使用我们的服务，从而针对性地回应您的个性化需求，例如个性化的帮助服务和指示，或对您和其他用户作出其他方面的回应； 软件认证或管理软件升级； 让您参与有关我们产品和服务的调查。 (2)为了让您有更好的体验，也为了改善我们的服务，在符合相关法律法规的前提下，我们可能将通过某一项服务收集信息或向第三方提供用户的非个人隐私信息的方式，用于我们的其他服务。例如，在您使用我们的一项服务时所收集的信息，可能会用于向您提供特定内容，或向您展示与您相关的、非普遍推送的信息。 4、隐私政策我们非常重视您的个人信息保护，依据最新的监管要求上线并更新了轻启药箱 《隐私政策》 该政策将帮助您了解以下内容：1、 我们如何收集和使用您的个人信息2、 我们如何使用 Cookie3、 您的个人信息如何存储以及在全球范围转移4、 我们如何共享、转让、公开披露您的个人信息5、 我们如何保护您的个人信息6、 您的权利7、 未成年人条款8、 本隐私政策时效及如何更新9、 如何联系我们10、其他 本隐私政策适用于「soyl.tech」的所有相关服务，请在使用我们的产品（或服务）前，仔细阅读并了解本《隐私政策》，我们会适时对隐私政策进行修订，请以该协议为准。 四、轻启药箱的服务 1、轻启药箱的服务轻启药箱是一款药箱类APP。轻启药箱向用户提供但不限于以下服务：药品信息的收集、整理、删除。轻启药箱有权对前述服务内容进行增减或调整。除非本协议另有其它明示规定，轻启药箱增加或强化目前本服务的任何新功能，包括所推出的新产品，均受本使用协议之规范。 2、设备(1) 您应当理解，您使用轻启药箱的服务需自行准备与相关服务有关的终端设备（如电脑、调制解调器等装置），并承担所需的费用（如电话费、上网费等费用）。(2) 您理解并同意，您使用本服务时会耗用您的终端设备和带宽等资源。 3、广告(1) 您同意轻启药箱可以在提供服务的过程中自行或由第三方广告商向您发送广告、推广或宣传信息（包括商业与非商业信息），其方式和范围可不经向您特别通知而变更。(2) 轻启药箱依照法律的规定对第三方广告商履行相关义务，您应当自行判断广告信息的真实性并为自己的判断行为负责，除法律明确规定外，您因依该广告信息进行的交易或前述广告商提功内容而遭受的损失或损害轻启药箱不承担责任。(3) 您同意，对轻启药箱服务中出现的广告信息，您应审慎判断其真实性和可靠性，除法律明确规定外，您应对依该广告信息进行的交易负责。(4) 您同意，所有对您收取费用的服务或功能，均不能免除您接受轻启药箱所提供的广告。因为这是轻启药箱为所有用户提供综合服务的有效对价，您阅读本协议即视为对该规则的理解和接受。 六、软件产品保护条款 (1) 本软件产品之著作权及其它知识产权等相关权利或利益（包括但不限于现已取得或未来可取得之著作权、专利权、商标权、营业秘密等）皆为Soyl Liu所有。本软件产品受中华人民共和国版权法及国际版权条约和其他知识产权法及条约的保护。用户仅获得本软件产品的非排他性使用权(2) 用户不得：删除本软件及其他副本上一切关于版权的信息；对本软件进行反向工程，如反汇编、反编译等；(3) 本软件产品以现状方式提供，Soyl Liu不保证本软件产品能够或不能够完全满足用户需求，在用户手册、帮助文件、使用说明书等软件文档中的介绍性内容仅供用户参考，不得理解为对用户所做的任何承诺。Soyl Liu保留对软件版本进行升级，对功能、内容、结构、界面、运行方式等进行修改或自动更新的权利。 (4) 为了更好地服务于用户，或为了向用户提供具有个性的信息内容的需要，本软件产品可能会收集、传播某些信息，但Soyl Liu承诺不向未经授权的第三方提供此类信息，以保护用户隐私。 (5) Soyl Liu定义的信息内容包括：文字、软件、声音；本公司为用户提供的商业信息，所有这些内容受版权、商标权、和其它知识产权和所有权法律的保护。所以，用户只能在本公司授权下才能使用这些内容，而不能擅自复制、修改、编撰这些内容、或创造与内容有关的衍生产品。 (6) 如果您未遵守本协议的任何一项条款，Soyl Liu有权立即终止本协议，并保留通过法律手段追究责任。 六、违法行为1、 您在使用本服务时须遵守法律法规，不得利用本服务从事违法违规行为，以及不得利用轻启药箱服务制作、上载、复制、发布、传播或者转载如下内容，包括但不限于：(1) 反对宪法所确定的基本原则的；(2) 危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的；(3) 损害国家荣誉和利益的；(4) 煽动民族仇恨、民族歧视，破坏民族团结的；(5) 破坏国家宗教政策，宣扬邪教和封建迷信的；(6) 散布谣言，扰乱社会秩序，破坏社会稳定的；(7) 散布淫秽、色情、赌博、暴力、凶杀、恐怖或者教唆犯罪的；(8) 侮辱或者诽谤他人，侵害他人合法权益的；(9) 含有法律、行政法规禁止的其他内容的信息。 2、 如果您违反了本条约定，相关国家机关或机构可能会对您提起诉讼、罚款或采取其他制裁措施，并要求轻启药箱给予协助。造成轻启药箱或第三方损害的，您应依法予以赔偿，轻启药箱不承担任何责任。 3、 如果轻启药箱发现或收到他人举报您发布的信息违反本条约定，轻启药箱有权进行独立判断并采取技术手段予以删除、屏蔽或断开链接。同时，轻启药箱有权视用户的行为性质，采取包括但不限于暂停或终止服务，限制、冻结或终止账号使用，追究法律责任等措施。 4、 您违反本条约定，导致任何第三方损害的，您应当独立承担责任；轻启药箱因此遭受损失的，您也应当一并赔偿。 5、 违反本条约定，视为您的严重违约，轻启药箱可以中止对您的服务，解除双方间的服务协议和法律关系，且无需退还您所支付的费用（如有），视为您支付轻启药箱的违约金，如不足以弥补轻启药箱的损失的，轻启药箱还可通过其他法律途径向您追索。 七、青少年用户特别提示青少年用户必须遵守全国青少年网络文明公约：要善于网上学习，不浏览不良信息；要诚实友好交流，不侮辱欺诈他人；要增强自护意识，不随意约会网友；要维护网络安全，不破坏网络秩序；要有益身心健康，不沉溺虚拟时空。 八、 不可抗力与免责1、您理解并同意，在使用轻启药箱服务的过程中，可能会遇到不可抗力等风险因素，使轻启药箱提供的服务发生中断。不可抗力是指不能预见、不能克服并不能避免且对一方或双方造成重大影响的客观事件，包括但不限于自然灾害如洪水、地震、瘟疫流行和风暴等，以及社会事件如战争、动乱、政府行为等。出现上述情况时，soyl.tech将努力在第一时间与相关单位配合，及时进行修复，但是由此给您造成的损失，soyl.tech在法律允许的范围内免责。 2、在法律允许的范围内，soyl.tech对以下情形导致的服务中断或受阻不承担责任：(1) 受到计算机病毒、木马或其他恶意程序、黑客攻击的破坏；(2) 用户或轻启药箱的电脑软件、系统、硬件和通信线路出现故障；(3) 用户操作不当；(4) 用户通过非轻启药箱授权的方式使用轻启药箱服务；(5) 其他轻启药箱无法控制或合理预见的情形。 3、您理解并同意，在使用轻启药箱服务的过程中，可能会遇到网络信息或其他用户行为带来的风险，轻启药箱不对非轻启药箱发布的任何信息的真实性、适用性、合法性承担责任，也不对因侵权行为给您造成的损害负责。这些风险包括但不限于：(1) 来自他人匿名或冒名的含有威胁、诽谤、令人反感或非法内容的信息；(2) 因使用本协议项下的服务，遭受他人误导、欺骗或其他导致或可能导致的任何心理、生理上的伤害以及经济上的损失；(3) 其他因网络信息或用户行为引起的风险。 4、您理解并同意，轻启药箱提供的服务并非为某些特定目的（包括但不限于核设施、军事用途、医疗设施、交通通讯等重要领域）而设计，如果因为软件或服务的原因导致上述操作失败而带来的人员伤亡、财产损失和环境破坏等，soyl.tech不承担法律责任。 5、soyl.tech依据本协议约定获得处理违法违规内容的权利，该权利不构成soyl.tech的义务或承诺，soyl.tech不能保证及时发现违法行为或进行相应处理。 6、在任何情况下，您不应轻信借款、索要密码或其他涉及财产的网络信息。涉及财产操作的，请一定先核实对方身份，并请经常留意轻启药箱或其他部门发布的有关防范诈骗犯罪的提示。 7、用户在soyl.tech发表的内容仅表明其个人的立场和观点，并不代表soyl.tech的立场或观点。作为内容的发表者，用户需自行对所发表内容负责，因所发表内容引发的一切纠纷，由该内容的发表者承担全部法律及连带责任；作为读者，用户应当自行对所看到的文章等内容进行甄别，并承担依照该等内容操作所带来的一切后果。soyl.tech不承担任何法律及连带责任。 九、协议的生效与修改1、 您进入轻启药箱并使用轻启药箱的服务即视为您已阅读本协议并接受本协议的约束。2、 轻启药箱有权在必要时修改本协议条款，您可以在相关服务页面查阅最新版本的协议条款。3、 本协议条款变更后，如果您继续使用轻启药箱提供的服务，即视为您已接受修改后的协议。如果您不接受修改后的协议，应当退出轻启药箱并停止使用轻启药箱提供的服务。 十、 有效期及终止1、 除本协议约定终止之情形外，本协议将会一直有效。2、 终止的情形：(1) 如你书面通知soyl.tech不接受本协议或对其的修改，轻启药箱有权随时终止向你提供本功能。(2) 因不可抗力因素导致你无法继续使用本功能或轻启药箱无法提供本功能的，soyl.tech有权随时终止协议(3) 本协议约定的其他终止条件发生或实现的，soyl.tech有权随时终止向你提供本功能。(4) 由于你违反本协议约定，轻启药箱依约终止向你提供本功能后，如你后续再直接或间接，或以他人名义注册使用本功能的，soyl.tech有权直接单方面暂停或终止提 供本功能。(5) 协议生效期间如遇国家法律、法规、国家相关部门及电信运营商有新相关文件出台或政策环境产生变化，致使本协议之签订、履行基础产生根本性变化的。 3、 如本协议或本功能因为任何原因终止的，对于你的帐户中的全部数据或你因使用本功能而存储在soyl.tech服务器中的数据等任何信息，soyl.tech可将该等信息保留或删除，包括服务终止前你尚未完成的任何数据。 4、 如本协议或本功能因为任何原因终止的，你应自行处理好关于数据等信息的备份以及与你的用户之间的相关事项的处理等。 十一、 其他1、 本协议的订立、执行和解释及争议的解决均应适用中华人民共和国法律。2、 如双方就本协议内容或其执行发生任何争议，双方应尽量友好协商解决；协商不成时，任何一方均可向百度公司所在地北京市海淀区人民法院提起诉讼。3、 如本协议中的任何条款无论因何种原因完全或部分无效或不具有执行力，本协议的其余条款仍应有效并且有约束力。","link":"/uncategorized/yonghuxieyi.html"},{"title":"Linux下安装MongoDB","text":"安装MongoDB 在mongo官网下载最新版本的安装包 https://www.mongodb.org/downloads#production 解压mongodb程序包解压文件 我这里为了方便，直接离线下载的程序包放到/usr/local/目录下，安装位置随意，注意下后面文件配置的路径就好了。 tar zxvf mongodb-linux-x86_64-rhel70-3.2.6.tgz 为了后面操作方便，改下文件名 mv mongodb-linux-x86_64-rhel70-3.2.6 mongodb 进入mongodb的目录 cd mongodb 新建mongdb的data和log目录 mkdir dbcd dbmkdir datamkdir logs 创建MongoDB.log文件 cd logsvi MongoDB.log#直接使用wq命令保存文件 新建mongo的conf文件cd ../binvi mongodb.conf 填入下面的内容，使用wq命令保存退出 dbpath=/usr/local/mongodb/db/datalogpath=/usr/local/mongodb/db/logs/MongoDB.logport=27017fork=truenohttpinterface=true 配置MongoDBmongodb的配置文件地址输入下面的命令 ./mongod -f /usr/local/mongodb/bin/mongodb.conf 弹出下面的内容则证明配置成功 [root@mjjw bin]# ./mongod -f /usr/local/mongodb/bin/mongodb.confabout to fork child process, waiting until server is ready for connections.forked process: 2292child process started successfully, parent exiting 这时候已经可以正常启动关闭了，启动是直接运行bin目录下的mongo文件 设置mongdb为自动启动vi /etc/rc.d/rc.local 在最后面填入下面的内容 /usr/local/mongodb/bin/mongod --config /usr/local/mongodb/bin/mongodb.conf","link":"/APP/MongoDB/linux_mongodb.html"},{"title":"macOS  brew安装redis","text":"安装Homebrew/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装完成后写上下面的配置，目的是为了关闭homebrew每次检查更新（加快速度） 关闭：export HOMEBREW_NO_AUTO_UPDATE=true打开：export HOMEBREW_NO_AUTO_UPDATE=false 安装Redisbrew install redis 命令 启动Redis#后台启动redis-server &amp; 关闭Redisredis-cli shutdown 验证程序redis-cli ping 看到pong就代表成功了 其他配置vim /usr/local/etc/redis.conf修改 daemonize no 为 daemonize yes 默认启动就后台运行其中修改密码是 requirepass foobared =&gt; requirepass pwdcode这里把密码设置成了pwdcode","link":"/APP/Redis/macos_brew_redis.html"},{"title":"Windows下安装MongoDB","text":"安装MongoDB 在mongo官网下载最新版本的安装包 https://www.mongodb.org/downloads#production 下载完直接安装就可以了 创建库目录和Log目录进入mongo的安装目录，在“bin”目录的同级创建“data”目录，然后在“data”目录下创建“db”和“logs”目录在logs目录下新建一个txt文件，将文件名改为MongoDB.log txt文件改为log格式文件 安装mongo管理员运行cmd，cd打开进入mongo的bin目录 cd C:\\Program Files\\MongoDB\\Server\\3.2\\bin 安装mongo mongod --dbpath \"C:\\Program Files\\MongoDB\\Server\\3.2\\data\\db\" --logpath \"C:\\Program Files\\MongoDB\\Server\\3.2\\data\\logs\\MongoDB.log\" --install --serviceName \"MongoDB\" 出现下面内容，生成一个以日期命名的log文件时就是安装成功了以后执行mongo都可以用windows的net启动命令就可以了 net start/stop/restart MongoDB 小问题重启后无法启动mongo问题当电脑突然断电或其他不正常关闭时，又可能会发生mongo无法启动的情况，网上的参考方法很多，但是我用的时候发现启动的时候不要指定log比较好，当然这样就找不到log文件了。这里先记录下启动的命令，更好的处理方法日后再做更改。 mongod –dbpath “C:\\Program Files\\MongoDB\\Server\\3.2\\data\\db” 使用客户端工具创建的库不能使用的问题不知道是不是我下载的版本有问题还是什么，总之用客户端创建的数据库刷新后mongo就给自动删除了。这时候创建数据库的方法是手工建库。进入mongo的bin目录，执行mongo.exe文件，输入下面命令 use mydbdbdb.movie.insert({\"name\":\"asdf\"})show dbs","link":"/APP/MongoDB/windows_mongodb_install.html"}],"tags":[{"name":"Document","slug":"Document","link":"/tags/Document/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"SwiftUI","slug":"SwiftUI","link":"/tags/SwiftUI/"},{"name":"VPN","slug":"VPN","link":"/tags/VPN/"},{"name":"Install","slug":"Install","link":"/tags/Install/"},{"name":"Xcode","slug":"Xcode","link":"/tags/Xcode/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"Architecture","slug":"Architecture","link":"/tags/Architecture/"},{"name":"Failed","slug":"Failed","link":"/tags/Failed/"},{"name":"JDK","slug":"JDK","link":"/tags/JDK/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"Svn","slug":"Svn","link":"/tags/Svn/"},{"name":"Command","slug":"Command","link":"/tags/Command/"},{"name":"Optimize","slug":"Optimize","link":"/tags/Optimize/"},{"name":"Tool","slug":"Tool","link":"/tags/Tool/"},{"name":"Tookit","slug":"Tookit","link":"/tags/Tookit/"},{"name":"Basis","slug":"Basis","link":"/tags/Basis/"},{"name":"Vapor","slug":"Vapor","link":"/tags/Vapor/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"}],"categories":[{"name":"Swift","slug":"Swift","link":"/categories/Swift/"},{"name":"SwiftUI","slug":"SwiftUI","link":"/categories/SwiftUI/"},{"name":"Vapor","slug":"Swift/Vapor","link":"/categories/Swift/Vapor/"},{"name":"APP","slug":"APP","link":"/categories/APP/"},{"name":"Core Data","slug":"Swift/Core-Data","link":"/categories/Swift/Core-Data/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"APP","slug":"Swift/Vapor/APP","link":"/categories/Swift/Vapor/APP/"},{"name":"Terminal","slug":"APP/Terminal","link":"/categories/APP/Terminal/"},{"name":"MyEclipse","slug":"APP/MyEclipse","link":"/categories/APP/MyEclipse/"},{"name":"Loadrunner","slug":"APP/Loadrunner","link":"/categories/APP/Loadrunner/"},{"name":"Sketch","slug":"APP/Sketch","link":"/categories/APP/Sketch/"},{"name":"FetchRequest","slug":"Swift/Core-Data/FetchRequest","link":"/categories/Swift/Core-Data/FetchRequest/"},{"name":"Redis","slug":"APP/Redis","link":"/categories/APP/Redis/"},{"name":"MySQL","slug":"APP/MySQL","link":"/categories/APP/MySQL/"},{"name":"Shadowsocks","slug":"APP/Shadowsocks","link":"/categories/APP/Shadowsocks/"},{"name":"Github","slug":"Git/Github","link":"/categories/Git/Github/"},{"name":"Mkit","slug":"Swift/Vapor/APP/Mkit","link":"/categories/Swift/Vapor/APP/Mkit/"},{"name":"Docker","slug":"APP/Docker","link":"/categories/APP/Docker/"},{"name":"Shadowsocks","slug":"APP/Terminal/Shadowsocks","link":"/categories/APP/Terminal/Shadowsocks/"},{"name":"MongoDB","slug":"APP/MongoDB","link":"/categories/APP/MongoDB/"}]}